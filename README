Information for the Slate Distribution
--------------------------------------

Copyright/License Information
-----------------------------

See the LICENSE file.

What is Slate?
--------------

Slate is a prototype-based, multi-dispatch object-oriented language that
runs from a highly-customizable live environment. The implementation is
highly portable and relatively lightweight.

Where do I learn more?
----------------------

The reference site for this Distribution is at http://www.slatelanguage.org
and the Google Code project at: http://code.google.com/p/slate-language/

Bug reports and requests for information can be made via the Slate mailing
list, described at: http://groups.google.com/group/slate-language

See the wiki for more detailed documentation:
 http://code.google.com/p/slate-language/w/list

See our bug-tracker for issues:
 http://code.google.com/p/slate-language/issues/list

Obtaining Slate
---------------

To get a slate repository on your computer to play with, run:
  git clone git://repo.or.cz/cslatevm.git

Setup
-----

'make' builds the VM.
'make slate.image' builds a standard saved image from a kernel image.
'make edit' launches the VM and standard image in Emacs with a scratch area.
'(sudo) make install' installs the VM and images in global directories (/usr/local/ by default) so that the VM can be invoked as just "slate".

You must also get an image to run slate with. If you don't have one,
you can download a clean image from: http://code.google.com/p/slate-language/downloads/list 
See the Bootstrapping section for how to make an image yourself.


Read common.mk for more makefile options.

Command Line
------------

./slate -i <image>

This starts slate using <image>.

Run 'slate -h' for more details.

Learning Slate
--------------

Read the online tutorials (from newest to oldest):

* http://slatelanguage.org/tutorial/
* http://code.google.com/p/slate-language/wiki/GettingStarted

Bootstrapping
-------------

If you make changes to core slate files (like adding a new field to
CompiledMethods), sometimes the only easy way to implement those changes
throughout the system is to rebuild Slate completely. Here is how you
generate a new kernel image:

From the shell:

 make bootstrap WORD_SIZE=64 && make slate.image WORD_SIZE=64
or
 make bootstrap WORD_SIZE=32 && make slate.image WORD_SIZE=32

From within Slate:

At the Slate REPL, execute:
 load: 'src/mobius/init.slate'.
then:
 Image bootstrap &littleEndian: True &bitSize: 32.
or
 Image bootstrap &littleEndian: True &bitSize: 64.

Then you will load the resulting kernel image like a regular image:

 ./slate -i kernel.new.<endian>.<wordsize>.<timestamp>.image

After the image is loaded, you will want to save it so you
don't have to go through loading the kernel again:

 Image saveNamed: 'slate.image'.


Debugging the VM
----------------

make vmclean && make DEBUG=1
gdb slate
r -i <image-file>
(on crash or Ctrl-c)
bt
f <n> (change frame to one with an 'oh' object (struct object_heap*))

See the slate backtrace -> print print_backtrace(oh)
Inspect an object       -> print print_detail(oh, struct Object*)
See the stack           -> print print_stack_types(oh, 200)


Source directory structure
--------------------------

src/vm
: The C files for the VM. Interprets bytecode and provides necessary facilities for primitives, gc, etc.
src/mobius -> The slate files for the compiler, lexer, bootstrap, and close-to-vm? facilities etc.
src/core
: The core libraries for the default slate system.
src/lib
: The standard but optional libraries.
src/plugins
: C code for slate FFI calls. `make plugins' to build
src/ui
: The slate UI code that probably calls plugins to draw the basics. load: 'src/ui/init.slate'.
src/ui/gtk
: The slate GTK interface. load: 'src/ui/gtk/demo.slate'.
src/net
: The slate networking code. load: 'src/net/init.slate'.

Finding source code
-------------------

Besides using grep, there are a few facilities:

 #as: implementations do: [|:each| each definitionLocation ifNotNilDo: [|:l| inform: (l as: String) ]].

 (#parseExpression findOn: {Syntax Parser}) definitionLocation

See the slate manual for more details.


Stack format / Calling convention
---------------------------------

We are about to call a function.
fp at the time of the activation is equal to the current stack pointer plus the function frame size
(which is 6).

stack[fp-6] -> the stack pointer before the stack allocation for this frame + localvars + registers is done
stack[fp-5] -> the absolute stack position (stack location) of where the callee should place its result
stack[fp-4] -> the code pointer (ip) of the caller
stack[fp-3] -> the callee's closure/method
stack[fp-2] -> the callee's lexical context (nil for stack allocated frames)
stack[fp-1] -> frame pointer of caller
stack[fp+0] .. stack[fp+registerCount+lvCount] -> registers + local variables
 
When you return from a function and you want to restore the frame in
the interpreter object to what it was before the call, you restore
everything based on fp (interpreter's current fp) except the closure
and the lexical context which are restored based on the saved
framepointer (at fp-1) using the previous frame (notice callee
vs. caller).


basic overview (code summary):

function calling -- interpreter_apply_to_arity_with_optionals():

  framePointer = i->stackPointer + FUNCTION_FRAME_SIZE;
  /* store the old stack pointer so we know what to return it to after this function ends */
  beforeCallStackPointer = i->stackPointer;
  interpreter_stack_allocate(oh, i, FUNCTION_FRAME_SIZE /*frame size in words*/ + object_to_smallint(method->localVariables) + object_to_smallint(method->registerCount));
  i->stack->elements[framePointer - 6] = smallint_to_object(beforeCallStackPointer);
  i->stack->elements[framePointer - 5] = smallint_to_object(resultStackPointer);
  i->stack->elements[framePointer - 4] = smallint_to_object(i->codePointer);
  i->stack->elements[framePointer - 3] = (struct Object*) closure;
  i->stack->elements[framePointer - 2] = (struct Object*) lexicalContext;
  i->stack->elements[framePointer - 1] = smallint_to_object(i->framePointer);
  i->framePointer = framePointer;
  i->method = method;
  i->closure = closure;
  i->lexicalContext = lexicalContext;


function returning -- interpreter_return_result()


  framePointer = i->framePointer;
  resultStackPointer = (word_t)i->stack->elements[framePointer - 5]>>1;
  i->stack->elements[resultStackPointer] = result;
  i->stackPointer = object_to_smallint(i->stack->elements[framePointer - 6]);
  i->framePointer = object_to_smallint(i->stack->elements[framePointer - 1]);
  i->codePointer = object_to_smallint(i->stack->elements[framePointer - 4]);
  i->lexicalContext = (struct LexicalContext*) i->stack->elements[i->framePointer - 2];
  i->closure = (struct Closure*) i->stack->elements[i->framePointer - 3];
  i->method = i->closure->method;
  i->codeSize = array_size(i->method->code);



Compiler
--------

A simple example:

~~~

[ | :c genCode|
genCode: (c generate:
[
 1 + 1
] 
method sourceTree result: Nil &topLevel: True) code.
c decompile: genCode
] applyWith: VM SSACompiler new.

~~~

Inside a function definition:

~~~

[ | :c genCode|
genCode: (c generate:
[
 block@(Method traits) on: c@(Condition traits) do: handler
[| context |
  context: (c cloneSettingSlots: #(handlers exitContinuation)
	      to: {{handler}. [| :result | ^ result]}).
  conditionStack push: context.
  block ensure: [conditionStack pop]
].

] 
method sourceTree result: Nil &topLevel: True) code.
c decompile: genCode third code
] applyWith: VM SSACompiler new.

~~~

Inside the closure:

~~~

[ | :c genCode|
genCode: (c generate:
[
 block@(Method traits) on: c@(Condition traits) do: handler
[| context |
  context: (c cloneSettingSlots: #(handlers exitContinuation)
	      to: {{handler}. [| :result | ^ result]}).
  conditionStack push: context.
  block ensure: [conditionStack pop]
].

] 
method sourceTree result: Nil &topLevel: True) code.
c decompile: (genCode third code at: 13) code
] applyWith: VM SSACompiler new.

~~~

See what is getting called:

~~~

VM SSACompiler new decompile: (#handle: findOn: {mainWindow. PaintEvent newContext: mainWindow context}) method code.

~~~
