Information for the Slate Distribution
--------------------------------------

 Slate is a prototype-based, multi-dispatch object-oriented language that
 runs from a highly-customizable live environment. The implementation is
 highly portable and relatively lightweight.

 The reference site for this Distribution is at http://www.slatelanguage.org
 and the Google Code project at: http://code.google.com/p/slate-language/

 Bug reports and requests for information can be made via the Slate mailing
 list, described at: http://groups.google.com/group/slate-language

 See the wiki for more detailed documentation:
 http://code.google.com/p/slate-language/w/list

 See our bug-tracker for issues:
 http://code.google.com/p/slate-language/issues/list

Setup
-----

'make' builds the VM.
'make slate.image' builds a standard saved image.
'make edit' launches the VM and standard image in Emacs with a scratch area.

Read common.mk for more options.

./slate -i kernel.image                 "initial bootstrap (see below for more details)"
Image saveNamed: 'my.image'.         "save current image"
./slate my.image                     "load a saved image"

Command Line
------------

./slate -i <image>

This starts slate using <image>.

Run 'slate -h' for more details.

Learning Slate
--------------

Read the TUTORIAL

Bootstrapping
-------------

If you make changes to core slate files (like adding a new field to
CompiledMethods), sometimes the only easy way to make those changes
throughout the system is to bootstrap again. Here is how you generate
a new kernel image:

Run slate to get a repl.

[
load: 'src/mobius/init.slate'.
Image littleEndian: True bitSize: 64.
] do.

or

[
load: 'src/mobius/init.slate'.
Image littleEndian: True bitSize: 32.
] do.

Then you will load it like a regular image:

./slate kernel.new.<endian>.<wordsize>.<timestamp>.image

Debugging
---------
make vmclean && make DEBUG=1
gdb slate
r <image-file>
(on crash or Ctrl-c)
bt
f <n> (change frame to one with an 'oh' object (struct object_heap*))

See the slate backtrace -> print print_backtrace(oh)
Inspect an object       -> print print_detail(oh, struct Object*)
See the stack           -> print print_stack_types(oh, 200)

Source directory structure
--------------------------

src/vm -> The C files for the VM. Interprets bytecode and provides necessary facilities for primitives, gc, etc.
src/mobius -> The slate files for the compiler, lexer, bootstrap, and close-to-vm? facilities etc.
src/lib -> The core and not-so-core libraries for slate
src/plugins -> C code for slate FFI calls. `make plugins' to build
src/ui -> The slate UI code that probably calls plugins to draw the basics. load: 'src/ui/init.slate'.
src/ui/gtk -> The slate GTK interface. load: 'src/ui/gtk/demo.slate'.
src/net -> The slate networking code. load: 'src/net/init.slate'.

Stack format
------------

The caller is about to call the callee.
fp at the time of the activation is equal to the current stack pointer plus the function frame size (6).

stack[fp-6] -> the stack pointer before the stack allocation for this frame + localvars + registers is done
stack[fp-5] -> the absolute position (stack location) of where the callee should place its result
stack[fp-4] -> the current code pointer (ip) of the caller
stack[fp-3] -> the callee's closure/method
stack[fp-2] -> the callee's lexical context (nil for stack allocated frames)
stack[fp-1] -> frame pointer of caller
stack[fp+0] .. stack[fp+lvCount+registerCount] -> local variables + registers

When you return from a function and you want to restore the frame in
the interpreter object to what it was before the call, you restore
everything based on fp (interpreter's current fp) except the closure
and the lexical context which are restored based on the saved
framepointer (at fp-1) using the previous frame (notice callee
vs. caller).

Compiler
--------

A simple example:

[ | :c genCode|
genCode: (c generate:
[
 1 + 1
] 
method sourceTree result: Nil &topLevel: True) code.
c decompile: genCode
] applyWith: VM SSACompiler new.



Inside a function definition:


[ | :c genCode|
genCode: (c generate:
[
 block@(Method traits) on: c@(Condition traits) do: handler
[| context |
  context: (c cloneSettingSlots: #(handlers exitContinuation)
	      to: {{handler}. [| :result | ^ result]}).
  conditionStack push: context.
  block ensure: [conditionStack pop]
].

] 
method sourceTree result: Nil &topLevel: True) code.
c decompile: genCode third code
] applyWith: VM SSACompiler new.


Inside the closure:

[ | :c genCode|
genCode: (c generate:
[
 block@(Method traits) on: c@(Condition traits) do: handler
[| context |
  context: (c cloneSettingSlots: #(handlers exitContinuation)
	      to: {{handler}. [| :result | ^ result]}).
  conditionStack push: context.
  block ensure: [conditionStack pop]
].

] 
method sourceTree result: Nil &topLevel: True) code.
c decompile: (genCode third code at: 13) code
] applyWith: VM SSACompiler new.


"see what is getting called"
VM SSACompiler new decompile: (#handle: findOn: {mainWindow. PaintEvent newContext: mainWindow context}) method code.


Finding source code
-------------------

Besides using grep (which is better since it will find bootstrap
code), there are a few facilities. See the slate manual for more
details.

#as: implementations do: [|:each| each definitionLocation ifNotNilDo: [|:l| inform: (l as: String) ]].

(#parseExpression findOn: {Syntax Parser}) definitionLocation

