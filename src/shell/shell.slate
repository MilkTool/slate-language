
d@(File Locator traits) maskedEntries: mask@(String traits) do: block
[
  d maskedEntries: (Glob newOn: mask) do: block
].

l maskedEntries: mask@(Regex Regex traits) do: block
[ 
  l maskedEntries: (Regex Matcher newOn: mask) do: block
].

l@(File Locator traits) maskedEntries: mask do: block
[ 
  (Directory new `>> [locator := l. ]) maskedEntries: mask do: block
].

l@(File Locator traits) collectMasked: mask
[
  [| :result | l maskedEntries: mask do: #(result nextPut: _) `er]
    writingAs: #{}
].

d@(File Locator traits) /* mask
[d collectMasked: mask].

d@(Directory traits) /* mask
[d locator collectMasked: mask].

d@(Directory traits) maskedEntries: mask do: block
[
  d sessionDo:
    [| :d |
     (d reader do:
        [| :each | (mask matches: each) ifTrue:
           [block applyWith: (File Locator new `>> [readFilenameFrom: each. ])]])].
].

d@(Directory traits) find: block &maxDepth: maxDepth
[
  maxDepth `defaultsTo: PositiveInfinity.
  result ::= Set new writer.
  d select: block into: result depth: maxDepth.
  result contents
].

d@(Directory traits) select: block into: result depth: maxDepth
[
  maxDepth isZero ifFalse:
    [entries ::= d entries collect:
       [| :each | (File RelativeLocator newFrom: d) `>> [readPathElementsFrom: each reader. ]].
     ((reader ::= entries reader) select: block) >> result.
     entries do:
       [| :each info |
        (info := each fileInfo) isNotNil /\ [info isDirectory] /\ [info isLink not]
          /\ [each name ~= '..'] /\ [each name ~= '.']
          ifTrue: [(d childNamed: each name) select: block into: result depth: maxDepth - 1]]]
].
