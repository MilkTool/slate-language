block@(Syntax Block traits) compile2 [
"Invoke the LLVM compiler."
	LLVM Compiler new generate: block
].

LLVM define: #Compiler &parents: {Cloneable} &slots: {#contexts -> Stack new}.

compiler@(LLVM Compiler traits) new [
	compiler clone `>> [ contexts: compiler contexts new. ]
].

LLVM Compiler traits define: #Context &parents: {Cloneable} &slots: {
	#isClosure -> False "Whether the method being compiled is a closure.".
	#method -> CompiledMethod new "The method the context targets.".
	#selectors -> ExtensibleArray new.
	"The gathering collection for the method's literal array; must be indexable
	before committing."
	#literals -> ExtensibleArray new.
	"The gathering collection for the method's selector array; must be indexable
	before committing."
}.

c@(LLVM Compiler Context traits) newOn: method
"FIXME change method code to array instead of bytearray."
[
  method code: Array new.
  c cloneSettingSlots: #(method selectors literals)
   to: {method. 
        c selectors new.
        c literals new}
].

c@(LLVM Compiler Context traits) copy
[resend `>> [selectors: c selectors copy.
             literals: c literals copy]].

c@(LLVM Compiler Context traits) flush
[
  c method literals: (c literals as: Array).
  c method selectors: (c selectors as: Array).
  c
].

compiler@(LLVM Compiler traits) currentContext [
	compiler contexts top
].

compiler@(LLVM Compiler traits) currentMethod [
	compiler currentContext method
].

compiler@(LLVM Compiler traits) literal: obj [
"Ensure that the literal object is included in the literals array. If it is
not present already, it is appended to the end, thus ensuring that no other
indices require shifting. Answer the literal's index."
	(compiler contexts top literals 
		indexOfFirstSatisfying: 
		[| :literal | obj = literal /\ [obj isSameAs: literal]])
		ifNil:
		[| index |
			index: compiler contexts top literals size.
			compiler contexts top literals addLast: obj.
			index]
].

compiler@(LLVM Compiler traits) selector: selector [
"Ensure that the literal object is included in the selectors array. If it is
not present already, it is appended to the end, thus ensuring that no other
indices require shifting. Answer the selector's index."
	compiler contexts top selectors `>> [include: selector. indexOf: selector]
].

_@(LLVM Compiler traits) generate: _@(Syntax Node traits) [
"Do nothing in the default case, for comments and annotations and such."
].

compiler@(LLVM Compiler traits) generate: ann@(Syntax Annotation traits) [
"Generate the annotation's value."
  compiler generate: ann value
].

compiler@(LLVM Compiler traits) generate: block@(Syntax Block traits) &topLevel: topLevel [
"Encountering a new block, build a new CompiledMethod object and push it and
a new bytecode array writer onto the generator, then go through the underlying
code and generate that. When done, pop both, set up the block as a literal
and push it onto the stack."
	| newBlock isClosure statements |
	inform: 'Block'.
	topLevel `defaultsTo: False.
	newBlock: CompiledMethod new.
	newBlock environment: (compiler contexts isEmpty
		ifTrue: [block parentScope topLevel namespace]
		ifFalse: [compiler currentMethod environment]).
	  newBlock sourceTree: block.
	compiler contexts push: (compiler Context newOn: newBlock).
	  "we macroexpand everything before we set the current register because macroexpansion can add localvariables etc"
	statements: (block statements collect: [| :statement | statement macroExpand &environment: compiler currentMethod sourceTree]).
	statements allButLastDo: [| :node | compiler generate: node].
	statements size > 0
		ifTrue: [ "returnRegister" compiler generate: statements last ]
		ifFalse: [ "returnValue" ].
	
	"Set the variable information after generation, just in case it was modified."
	newBlock `>>
	[inputVariables: block inputVariables size.
		localVariables: block localVariables size.
		restVariable: block restVariable isNotNil.
		optionalKeywords: block optionalKeywords.].
	isClosure: compiler currentContext isClosure.
	
	compiler contexts pop flush.
	"Forces the newBlock to record all the remaining stream input correctly."
	
	compiler contexts isEmpty \/ [topLevel] ifFalse: [
		isClosure
			ifTrue: ["newClosure" ]
			ifFalse: ["loadLiteral"]
	].	
].

compiler@(LLVM Compiler traits) generate: def@(Syntax MethodDefinition traits) [
"Translate method definitions to equivalent asMethod:on: invocations."
	inform: 'MethodDefinition'.
  	compiler contexts isEmpty ifTrue: [ ^ resend ].
  	#visit: sendTo: {gen. def} through: {gen. Syntax Block}.
	def roles do: [ |:role | compiler generate: role ].
	"directSendMessage"
].

compiler@(LLVM Compiler traits) generate: r@(Syntax Resend traits) [
	| lexOffset scope |
	inform: 'Resend'.
	scope: compiler currentMethod sourceTree.
	lexOffset: compiler contexts indexLast -
		((compiler contexts indexOfLastSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
		ifNil:
			[error: 'resend must be used within a method definition.']).
	lexOffset > 0
		ifTrue:
		[(compiler contexts fromTop: lexOffset) method heapAllocate: True.
			(compiler contexts top: lexOffset) do: #isClosure: `er <-* True].
	"resendMessage"
].

compiler@(LLVM Compiler traits) generate: r@(Syntax Return traits) [
	overrideThis
].

compiler@(LLVM Compiler traits) generate: r@(Syntax Return traits) by: lexOffset [ 
	inform: 'Return'.
	lexOffset > 0
		ifTrue:
		[(compiler contexts fromTop: lexOffset) method heapAllocate: True.
		(compiler contexts top: lexOffset) do: [| :x | x isClosure: True]].
	compiler generate: r value.
	"returnFrom"
].

compiler@(LLVM Compiler traits) generate: r@(Syntax ReturnClose traits) [
"Exits the first enclosing named method in the lexical scope."
	| lexOffset |
	inform: 'ReturnClose'.
  	lexOffset: compiler contexts indexLast -
		((compiler contexts indexOfLastSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
		ifNil:
			[error: '^ must be used within a method definition.']).
	compiler generate: r by: lexOffset
].

compiler@(LLVM Compiler traits) generate: r@(Syntax ReturnFar traits) [
"Exits the last enclosing named method in the lexical scope."
	| lexOffset |
	inform: 'ReturnFar'.
	lexOffset: compiler contexts indexLast -
		((compiler contexts indexOfFirstSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
			ifNil: [error: '^^ must be used within a method definition.']).
	compiler generate: r by: lexOffset
].

compiler@(LLVM Compiler traits) generate: r@(Syntax ReturnLevel traits) [
	"Exits the Nth enclosing lexical scope."
	inform: 'ReturnLevel'.
	compiler generate: r by: r level
].

compiler@(LLVM Compiler traits) generate: literal@(Syntax Literal traits) [
	inform: ('Literal[' ; (compiler literal: literal) printString ; ']: ' ; literal printString).
].

compiler@(LLVM Compiler traits) generate: n@(Syntax CompoundStatement traits) [
"return the registers that the values were saved into"
	inform: 'CompoundStatement'.
	n statements do: [
		| :node |
		compiler generate: node
	]
].

compiler@(LLVM Compiler traits) generate: n@(Syntax Parenthesis traits) [
"return the registers that the values were saved into"
	inform: 'Parenthesis'.
	n statements do: [
		| :node |
		compiler generate: node
	]
].

compiler@(LLVM Compiler traits) generate: i@(Syntax ImplicitArgument traits) [
	inform: 'ImplicitArgument'.
].

compiler@(LLVM Compiler traits) generate: _@(Syntax Namespace traits) [
	shouldNotImplement
].

compiler@(LLVM Compiler traits) generate: load@(Syntax LoadVariable traits) [
	| scope lexOffset varIndex |
	inform: 'LoadVariable'.
	scope: load variable scope.
	varIndex: (scope localVariables indexOf: load variable).
	lexOffset: compiler contexts indexLast -
		((compiler contexts indexOfLastSatisfying: [| :context | context method sourceTree == scope])
			ifNil: [error: 'Could not determine variable scope.']).
].

compiler@(LLVM Compiler traits) generate: store@(Syntax StoreVariable traits) [
	| scope lexOffset varIndex |
	inform: 'StoreVariable'.
	scope: store variable scope.
	varIndex: (scope localVariables indexOf: store variable).
	lexOffset: compiler contexts indexLast -
		((compiler contexts indexOfLastSatisfying: [| :context | context method sourceTree == scope])
			ifNil:[ error: 'Could not determine variable scope.']).
].

compiler@(LLVM Compiler traits) generate: array@(Syntax Array traits) [
"Generate the code to push the element expression results on the stack,
then the appropriate literal-array constructor bytecode."
	inform: 'Array'.
].

compiler@(LLVM Compiler traits) generate: selector@(Symbol traits) on: args from: msg@(Syntax Message traits) [
"Generate the code to push the argument expression results on the stack, then
the push for the selector, and then the appropriate message send bytecode."
	inform: ('Selector: '; selector).
	args do: [| :arg | compiler generate: arg].
].

compiler@(LLVM Compiler traits) generate: msg@(Syntax Message traits) &optionals: opts [
	inform: 'Message'.
	compiler generate: msg selector on: msg arguments from: (opts ifNil: [msg])
].

compiler@(LLVM Compiler traits) generate: macro@(Syntax Macro traits) &optionals: opts [
  "compiler generate: (macro macroExpand &optionals: opts &environment: compiler currentMethod sourceTree)"
	error: 'SSA Compiler cannot support macroexpansion at code generation time because of localVariable side-effects'.
].

compiler@(LLVM Compiler traits) generate: def@(Syntax Deferred traits) &optionals: opts [
	| block message |
	inform: 'Deferred'.
	block: Syntax Block new `>> [parentScope: compiler currentMethod sourceTree. ].
	def arguments size timesRepeat: #addInputVariable `er <- block.
	message: (Syntax Message sending: def selector to:
		(block inputVariables collect: [| :var | Syntax LoadVariable from: var])).
	opts
		ifNotNil:
		[message:
			((Syntax OptionalArguments for: message)
			`>> [arguments: (opts arguments deepCopy: block). ])].
	block statements: {message}.
	compiler generate:
		(Syntax KeywordMessage
		sending: #whenFulfilled:
		to: {def arguments as: Syntax Array. block})
].

compiler@(LLVM Compiler traits) generate: selector@(Symbol traits) on: args from: opts@(Syntax OptionalKeywords traits) [ 
"Generate the code to push the argument expression results on the stack, then
the push for the selector, and then the appropriate message send bytecode."
	inform: 'OptionalKeywords+'.
	args do: [| :arg | compiler generate: arg ].
	opts keywords with: opts arguments do: [
		| :key :arg |
		compiler generate: arg
	]
].

compiler@(LLVM Compiler traits) generate: opts@(Syntax OptionalKeywords traits) [
	inform: 'OptionalKeywords'.
	compiler generate: opts message &optionals: opts
].

