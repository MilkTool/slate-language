block@(Syntax Block traits) compile2 [
"Invoke the LLVM c."
	LLVM Compiler new generate: block
].

LLVM define: #Compiler &parents: {Cloneable} &slots: {#contexts -> Stack new. #module. #builder}.

(LLVM Compiler hasSlotNamed: #DefaultModule) ifTrue: [
	LLVM Compiler DefaultModule dispose.
].

LLVM Compiler define: #DefaultModule -> (
	(LLVM SlateModule new &name: 'slate')
).

module@(LLVM Compiler DefaultModule) shutdown [
	module dispose.
].

c@(LLVM Compiler traits) new &module: useModule [
	useModule `defaultsTo: LLVM Compiler DefaultModule.
	c clone `>> [ 
		contexts: c contexts new.
		module: useModule.
		builder: LLVM IRBuilder new.
	]
].

LLVM Compiler traits define: #Context &parents: {Cloneable} &slots: {
	#isClosure -> False "Whether the method being compiled is a closure.".
	#method -> CompiledMethod new "The method the context targets.".
	#selectors -> ExtensibleArray new.
	"The gathering collection for the method's literal array; must be indexable
	before committing."
	#literals -> ExtensibleArray new.
	"The gathering collection for the method's selector array; must be indexable
	before committing."
}.

c@(LLVM Compiler Context traits) newOn: method
"FIXME change method code to array instead of bytearray."
[
  method code: Array new.
  c cloneSettingSlots: #(method selectors literals)
   to: {method. 
        c selectors new.
        c literals new}
].

c@(LLVM Compiler Context traits) copy
[resend `>> [selectors: c selectors copy.
             literals: c literals copy]].

c@(LLVM Compiler Context traits) flush
[
  c method literals: (c literals as: Array).
  c method selectors: (c selectors as: Array).
  c
].

c@(LLVM Compiler traits) currentContext [
	c contexts top
].

c@(LLVM Compiler traits) currentMethod [
	c currentContext method
].

c@(LLVM Compiler traits) number: si@(SmallInteger) [
	si << 1 bitOr: 1
].

c@(LLVM Compiler traits) literal: obj [
"Ensure that the literal object is included in the literals array. If it is
not present already, it is appended to the end, thus ensuring that no other
indices require shifting. Answer the literal's index."
	(c contexts top literals 
		indexOfFirstSatisfying: 
		[| :literal | obj = literal /\ [obj isSameAs: literal]])
		ifNil:
		[| index |
			index: c contexts top literals size.
			c contexts top literals addLast: obj.
			index]
].

c@(LLVM Compiler traits) selector: selector [
"Ensure that the literal object is included in the selectors array. If it is
not present already, it is appended to the end, thus ensuring that no other
indices require shifting. Answer the selector's index."
	c contexts top selectors `>> [include: selector. indexOf: selector]
].

_@(LLVM Compiler traits) generate: _@(Syntax Node traits) [
"Do nothing in the default case, for comments and annotations and such."
].

c@(LLVM Compiler traits) generate: ann@(Syntax Annotation traits) [
"Generate the annotation's value."
inform: 'Annotation'.
 	shouldImplement.
 c generate: ann value
].

c@(LLVM Compiler traits) generate: block@(Syntax Block traits) &topLevel: topLevel [
"Encountering a new block, build a new CompiledMethod object and push it and
a new bytecode array writer onto the generator, then go through the underlying
code and generate that. When done, pop both, set up the block as a literal
and push it onto the stack."
	| newBlock isClosure statements functionType function |
	inform: 'Block'.
	topLevel `defaultsTo: False.
	topLevel ifTrue: [
		functionType: (LLVM Type Function new &returnType: c module structObjectPtr ).
		function: (c module addFunctionNamed: 'unnamedBlock' type: functionType).
		c builder insertPoint: (function addBlockNamed: 'entry').
	].
  	
	newBlock: CompiledMethod new.
	newBlock environment: (c contexts isEmpty
		ifTrue: [block parentScope topLevel namespace]
		ifFalse: [c currentMethod environment]).
	  newBlock sourceTree: block.
	c contexts push: (c Context newOn: newBlock).
	  "we macroexpand everything before we set the current register because macroexpansion can add localvariables etc"
	statements: (block statements collect: [| :statement | statement macroExpand &environment: c currentMethod sourceTree]).
	statements allButLastDo: [| :node | c generate: node].
	statements size > 0
		ifTrue: [ c builder ret &value: (c generate: statements last) ]
		ifFalse: [ "returnValue" inform: 'Return: Nil' ].
	
	"Set the variable information after generation, just in case it was modified."
	newBlock `>>
	[inputVariables: block inputVariables size.
		localVariables: block localVariables size.
		restVariable: block restVariable isNotNil.
		optionalKeywords: block optionalKeywords.].
	isClosure: c currentContext isClosure.
	
	c contexts pop flush.
	"Forces the newBlock to record all the remaining stream input correctly."
	
	c contexts isEmpty \/ [topLevel] ifFalse: [
		isClosure
			ifTrue: ["newClosure" shouldImplement ]
			ifFalse: ["loadLiteral" shouldImplement ]
	].	

	topLevel ifTrue: [ function verify &failureAction: LLVM VerifierFailureAction PrintMessage ].
	newBlock reserved5: function name intern.
	newBlock
].

c@(LLVM Compiler traits) generate: def@(Syntax MethodDefinition traits) [
"Translate method definitions to equivalent asMethod:on: invocations."
	inform: 'MethodDefinition'.
	shouldImplement.
	c contexts isEmpty ifTrue: [ ^ resend ].
  	#generate: sendTo: {c. def} through: {c. Syntax Block}.
	def roles do: [ |:role | c generate: role ].
	"directSendMessage"
].

c@(LLVM Compiler traits) generate: r@(Syntax Resend traits) [
	| lexOffset scope |
	inform: 'Resend'.
	shouldImplement.
	scope: c currentMethod sourceTree.
	lexOffset: c contexts indexLast -
		((c contexts indexOfLastSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
		ifNil:
			[error: 'resend must be used within a method definition.']).
	lexOffset > 0
		ifTrue:
		[(c contexts fromTop: lexOffset) method heapAllocate: True.
			(c contexts top: lexOffset) do: #isClosure: `er <-* True].
	"resendMessage"
].

c@(LLVM Compiler traits) generate: r@(Syntax Return traits) [
	overrideThis
].

c@(LLVM Compiler traits) generate: r@(Syntax Return traits) by: lexOffset [ 
	inform: 'Return'.
	shouldImplement.
	lexOffset > 0
		ifTrue:
		[(c contexts fromTop: lexOffset) method heapAllocate: True.
		(c contexts top: lexOffset) do: [| :x | x isClosure: True]].
	c generate: r value.
	"returnFrom"
].

c@(LLVM Compiler traits) generate: r@(Syntax ReturnClose traits) [
"Exits the first enclosing named method in the lexical scope."
	| lexOffset |
	inform: 'ReturnClose'.
 	shouldImplement.
 	lexOffset: c contexts indexLast -
		((c contexts indexOfLastSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
		ifNil:
			[error: '^ must be used within a method definition.']).
	c generate: r by: lexOffset
].

c@(LLVM Compiler traits) generate: r@(Syntax ReturnFar traits) [
"Exits the last enclosing named method in the lexical scope."
	| lexOffset |
	inform: 'ReturnFar'.
	shouldImplement.
	lexOffset: c contexts indexLast -
		((c contexts indexOfFirstSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
			ifNil: [error: '^^ must be used within a method definition.']).
	c generate: r by: lexOffset
].

c@(LLVM Compiler traits) generate: r@(Syntax ReturnLevel traits) [
	"Exits the Nth enclosing lexical scope."
	inform: 'ReturnLevel'.
	shouldImplement.
	c generate: r by: r level
].

c@(LLVM Compiler traits) generate: literal@(Syntax Literal traits) [
	| value |
	inform: ('Literal: ' ; literal printString).
	value: literal value.
	(value is: SmallInteger)
		ifTrue: [ LLVM Type Integer32 value: (c number: value) signed: True ]
		ifFalse: [ | index function |
			index: (LLVM Type Integer32 value: (c literal: literal value) signed: True).
			function: (c module functionNamed: 'literalAt').
			c builder call: function arguments: { index } &name: 'literal'
 		]
].

c@(LLVM Compiler traits) generate: n@(Syntax CompoundStatement traits) [
"return the registers that the values were saved into"
	inform: 'CompoundStatement'.
	n statements size < 1
    	ifTrue: [
			{}
		]
    	ifFalse: [
			n statements collect: [ | :node | c generate: node ]
		]
].

c@(LLVM Compiler traits) generate: n@(Syntax Parenthesis traits) [
"return the registers that the values were saved into"
	inform: 'Parenthesis'.
	n statements size < 1
    	ifTrue: [
			{}
		]
    	ifFalse: [
			n statements allButLastDo: [ | :node | c generate: node ].
			c generate: n statements last
		]
].

c@(LLVM Compiler traits) generate: i@(Syntax ImplicitArgument traits) [
	| function |
	inform: 'ImplicitArgument'.	
	function: (c module functionNamed: 'environment').
	c builder call: function arguments: {} &name: 'environment'
].

c@(LLVM Compiler traits) generate: _@(Syntax Namespace traits) [
	shouldNotImplement
].

c@(LLVM Compiler traits) generate: load@(Syntax LoadVariable traits) [
	| scope lexOffset varIndex |
	inform: 'LoadVariable'.
	scope: load variable scope.
	varIndex: (scope localVariables indexOf: load variable).
	lexOffset: c contexts indexLast -
		((c contexts indexOfLastSatisfying: [| :context | context method sourceTree == scope])
			ifNil: [error: 'Could not determine variable scope.']).

  lexOffset isZero
    ifTrue: [ | index function |
		index: (c generate: (Syntax Literal for: varIndex)).
		function: (c module functionNamed: 'variableAt').
		c builder call: function arguments: { index } &name: 'variable'
	]
    ifFalse: [
		shouldImplement.
		"result `defaultsTo: gen newRegister.
       (gen contexts fromTop: lexOffset) method heapAllocate: True.
       (gen contexts top: lexOffset) do: #isClosure: `er <-* True.
       gen emitInstruction: gen loadFreeVariable withParameters: {result. lexOffset. varIndex} from: load"
	]
].

c@(LLVM Compiler traits) generate: store@(Syntax StoreVariable traits) [
	| scope lexOffset varIndex |
	inform: 'StoreVariable'.
	scope: store variable scope.
	varIndex: (scope localVariables indexOf: store variable).
	lexOffset: c contexts indexLast -
		((c contexts indexOfLastSatisfying: [| :context | context method sourceTree == scope])
			ifNil:[ error: 'Could not determine variable scope.']).
  
  lexOffset isZero
    ifTrue: [ | index value function |
		index: (c generate: (Syntax Literal for: varIndex)).
		value: (c generate: store value).
		function: (c module functionNamed: 'variableAtPut').
		c builder call: function arguments: { index. value }.
		value
	]
    ifFalse: [
    	shouldImplement.
       	"gen generate: store value result: result.
       	(gen contexts fromTop: lexOffset) method heapAllocate: True.
       	(gen contexts top: lexOffset) do: #isClosure: `er <-* True.
        gen emitInstruction: gen storeFreeVariable withParameters: {lexOffset. varIndex} from: store"
	]
].

c@(LLVM Compiler traits) generate: array@(Syntax Array traits) [
"Generate the code to push the element expression results on the stack,
then the appropriate literal-array constructor bytecode."
	| arrayTrait arraySize newSizeSelector array registers atPutSelector |
	inform: 'Array'.
	registers: resend.
  	arrayTrait: (c generate: (Syntax UnaryMessage sending: #Array)).
  	newSizeSelector: (c emitSelector: #newSize:).
  	arraySize: (c generate: (Syntax Literal for: registers size)).
  	array: (c emitSendSelector: newSizeSelector on: {arrayTrait. arraySize} &name: 'array' ).
  	atPutSelector: (c emitSelector: #at:put:).
 	registers doWithIndex: [ | :value :index indexRegister |
 		indexRegister: (c generate: (Syntax Literal for: index)). 		
  		c emitSendSelector: atPutSelector on: {array. indexRegister. value} &name: 'value'
	].
	array
].

c@(LLVM Compiler traits) emitSelector: selector@(Symbol traits) [
  	"declare the selector, but access it as a literal"
	c selector: selector.
	c generate: (Syntax Literal for: selector)
].

c@(LLVM Compiler traits) emitSendSelector: selector@(LLVM Value traits) on: argRegisters &name: name [
"Generate the code to push the argument expression results on the stack, then
the push for the selector, and then the appropriate message send bytecode."
 	| argRegisters function |
 	name `defaultsTo: 'send'.
	inform: 'Message++'.
 	function: (argRegisters size caseOf: {
 		1 -> [ c module functionNamed: 'sendWith' ].
 		2 -> [ c module functionNamed: 'sendWithWith' ].
 		3 -> [ c module functionNamed: 'sendWithWithWith' ]
		} otherwise: [ shouldImplement ]
	).
	c builder call: function arguments: { selector } ; argRegisters &name: name
].

c@(LLVM Compiler traits) generate: selector@(Symbol traits) on: args from: msg@(Syntax Message traits) [
"Generate the code to push the argument expression results on the stack, then
the push for the selector, and then the appropriate message send bytecode."
 	| argRegisters selectorRegister function |
	inform: 'Message+'.
	selectorRegister: (c emitSelector: selector).
  	argRegisters: ( args collect: [ | :arg | c generate: arg ] ).
	c emitSendSelector: selectorRegister on: argRegisters &name: selector
].

c@(LLVM Compiler traits) generate: msg@(Syntax Message traits) &optionals: opts [
	inform: 'Message'.
	opts `defaultsTo: msg.
  	c generate: msg selector on: msg arguments from: opts
].

c@(LLVM Compiler traits) generate: macro@(Syntax Macro traits) &optionals: opts [
  "c generate: (macro macroExpand &optionals: opts &environment: c currentMethod sourceTree)"
	error: 'SSA Compiler cannot support macroexpansion at code generation time because of localVariable side-effects'.
].

c@(LLVM Compiler traits) generate: def@(Syntax Deferred traits) &optionals: opts [
	| block message |
	inform: 'Deferred'.
	shouldImplement.
	block: Syntax Block new `>> [parentScope: c currentMethod sourceTree. ].
	def arguments size timesRepeat: #addInputVariable `er <- block.
	message: (Syntax Message sending: def selector to:
		(block inputVariables collect: [| :var | Syntax LoadVariable from: var])).
	opts
		ifNotNil:
		[message:
			((Syntax OptionalArguments for: message)
			`>> [arguments: (opts arguments deepCopy: block). ])].
	block statements: {message}.
	c generate:
		(Syntax KeywordMessage
		sending: #whenFulfilled:
		to: {def arguments as: Syntax Array. block})
].

c@(LLVM Compiler traits) generate: selector@(Symbol traits) on: args from: opts@(Syntax OptionalKeywords traits) [ 
"Generate the code to push the argument expression results on the stack, then
the push for the selector, and then the appropriate message send bytecode."
	inform: 'OptionalKeywords+'.
	shouldImplement.
	args do: [| :arg | c generate: arg ].
	opts keywords with: opts arguments do: [
		| :key :arg |
		c generate: arg
	]
].

c@(LLVM Compiler traits) generate: opts@(Syntax OptionalKeywords traits) [
	inform: 'OptionalKeywords'.
	c generate: opts message &optionals: opts
].

