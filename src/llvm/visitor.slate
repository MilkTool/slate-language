ensureNamespace: #LLVM.
 
block@(Syntax Block traits) translate [
"Invoke the LLVM compiler."
	LLVM Visitor new visit: block
].

LLVM define: #Visitor &parents: {Cloneable} &slots: {#contexts -> Stack new}.

visitor@(LLVM Visitor traits) new [
	visitor clone `>> [ contexts: visitor contexts new. ]
].

visitor@(LLVM Visitor traits) currentContext [
	visitor contexts top
].

visitor@(LLVM Visitor traits) currentMethod [
	visitor currentContext method
].

visitor@(LLVM Visitor traits) newLabel [
	| label |
	label: visitor currentContext labels size.
	visitor currentContext labels addLast: Nil.
	label
].

_@(LLVM Visitor traits) visit: _@(Syntax Node traits) [
"Do nothing in the default case, for comments and annotations and such."
].

visitor@(LLVM Visitor traits) visit: ann@(Syntax Annotation traits) [
"Generate the annotation's value."
  visitor visit: ann value
].

visitor@(LLVM Visitor traits) visit: block@(Syntax Block traits) &topLevel: topLevel [
"Encountering a new block, build a new CompiledMethod object and push it and
a new bytecode array writer onto the generator, then go through the underlying
code and generate that. When done, pop both, set up the block as a literal
and push it onto the stack."
	| newBlock isClosure statements |
	topLevel `defaultsTo: False.
	newBlock: CompiledMethod new.
	newBlock environment: (visitor contexts isEmpty
		ifTrue: [block parentScope topLevel namespace]
		ifFalse: [visitor currentMethod environment]).
	  newBlock sourceTree: block.
	visitor contexts push: (visitor Context newOn: newBlock).
	  "we macroexpand everything before we set the current register because macroexpansion can add localvariables etc"
	statements: (block statements collect: [| :statement | statement macroExpand &environment: visitor currentMethod sourceTree]).
	visitor currentContext currentRegister: block localVariables size. "input variables might not be needed"
	statements allButLastDo: [| :node | visitor visit: node].
	statements size > 0
		ifTrue: [ "returnRegister" visitor visit: statements last ]
		ifFalse: [ "returnValue" ].
	
	"Set the variable information after generation, just in case it was modified."
	newBlock `>>
	[inputVariables: block inputVariables size.
		localVariables: block localVariables size.
		restVariable: block restVariable isNotNil.
		registerCount: visitor currentContext currentRegister + 1.
		"reserved1: visitor currentContext currentRegister + 1."
		optionalKeywords: block optionalKeywords.].
	isClosure: visitor currentContext isClosure.
	
	visitor contexts pop flush.
	"Forces the newBlock to record all the remaining stream input correctly."
	
	visitor contexts isEmpty \/ [topLevel] ifFalse: [
		isClosure
			ifTrue: ["newClosure" ]
			ifFalse: ["loadLiteral"]
	].	
].

visitor@(LLVM Visitor traits) visit: def@(Syntax MethodDefinition traits) [
"Translate method definitions to equivalent asMethod:on: invocations."
  	visitor contexts isEmpty ifTrue: [ ^ resend ].
	def roles do: [ 
		|:role |
		visitor visit: role
	]
].

visitor@(LLVM Visitor traits) visit: r@(Syntax Resend traits) [
	| lexOffset scope |
	scope: visitor currentMethod sourceTree.
	lexOffset: visitor contexts indexLast -
		((visitor contexts indexOfLastSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
		ifNil:
			[error: 'resend must be used within a method definition.']).
	lexOffset > 0
		ifTrue:
		[(visitor contexts fromTop: lexOffset) method heapAllocate: True.
			(visitor contexts top: lexOffset) do: #isClosure: `er <-* True].
	"resendMessage"
].

visitor@(LLVM Visitor traits) visit: r@(Syntax Return traits) [
	overrideThis
].

visitor@(LLVM Visitor traits) visit: r@(Syntax Return traits) by: lexOffset [ 
	lexOffset > 0
		ifTrue:
		[(visitor contexts fromTop: lexOffset) method heapAllocate: True.
		(visitor contexts top: lexOffset) do: [| :x | x isClosure: True]].
	visitor visit: r value.
	"returnFrom"
].

visitor@(LLVM Visitor traits) visit: r@(Syntax ReturnClose traits) [
"Exits the first enclosing named method in the lexical scope."
	| lexOffset |
  lexOffset: visitor contexts indexLast -
    ((visitor contexts indexOfLastSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
      ifNil:
        [error: '^ must be used within a method definition.']).
  visitor visit: r by: lexOffset result: resultRegister
].

visitor@(LLVM Visitor traits) visit: r@(Syntax ReturnFar traits) [
"Exits the last enclosing named method in the lexical scope."
	| lexOffset |
	lexOffset: visitor contexts indexLast -
		((visitor contexts indexOfFirstSatisfying: [| :context | context method sourceTree isSameAs: Syntax MethodDefinition])
			ifNil: [error: '^^ must be used within a method definition.']).
	visitor visit: r by: lexOffset
].

visitor@(LLVM Visitor traits) visit: r@(Syntax ReturnLevel traits) [
	"Exits the Nth enclosing lexical scope."
	visitor visit: r by: r level
].

visitor@(LLVM Visitor traits) visit: literal@(Syntax Literal traits) [
].

visitor@(LLVM Visitor traits) visit: n@(Syntax CompoundStatement traits) [
"return the registers that the values were saved into"
	n statements do: [
		| :node |
		visitor visit: node
	]
].

visitor@(LLVM Visitor traits) visit: n@(Syntax Parenthesis traits) [
"return the registers that the values were saved into"
	n statements do: [
		| :node |
		visitor visit: node
	]
].

visitor@(LLVM Visitor traits) visit: i@(Syntax ImplicitArgument traits) [
].

visitor@(LLVM Visitor traits) visit: _@(Syntax Namespace traits) [
	shouldNotImplement
].

visitor@(LLVM Visitor traits) visit: load@(Syntax LoadVariable traits) [
	| scope lexOffset varIndex |
	scope: load variable scope.
	varIndex: (scope localVariables indexOf: load variable).
	lexOffset: visitor contexts indexLast -
		((visitor contexts indexOfLastSatisfying: [| :context | context method sourceTree == scope])
			ifNil: [error: 'Could not determine variable scope.']).
].

visitor@(LLVM Visitor traits) visit: store@(Syntax StoreVariable traits) [
	| scope lexOffset varIndex |
	scope: store variable scope.
	varIndex: (scope localVariables indexOf: store variable).
	lexOffset: visitor contexts indexLast -
		((visitor contexts indexOfLastSatisfying: [| :context | context method sourceTree == scope])
			ifNil:[ error: 'Could not determine variable scope.']).
].

visitor@(LLVM Visitor traits) visit: array@(Syntax Array traits) [
"Generate the code to push the element expression results on the stack,
then the appropriate literal-array constructor bytecode."
].

visitor@(LLVM Visitor traits) visit: selector@(Symbol traits) on: args from: msg@(Syntax Message traits) [
"Generate the code to push the argument expression results on the stack, then
the push for the selector, and then the appropriate message send bytecode."
	args do: [| :arg | visitor visit: arg].
].

visitor@(LLVM Visitor traits) visit: msg@(Syntax Message traits) &optionals: opts [
	visitor visit: msg selector on: msg arguments from: (opts ifNil: [msg])
].

visitor@(LLVM Visitor traits) visit: macro@(Syntax Macro traits) &optionals: opts [
  "visitor visit: (macro macroExpand &optionals: opts &environment: visitor currentMethod sourceTree) result: result"
	error: 'SSA Compiler cannot support macroexpansion at code generation time because of localVariable side-effects'.
].

visitor@(LLVM Visitor traits) visit: def@(Syntax Deferred traits) &optionals: opts [
	| block message |
	block: Syntax Block new `>> [parentScope: visitor currentMethod sourceTree. ].
	def arguments size timesRepeat: #addInputVariable `er <- block.
	message: (Syntax Message sending: def selector to:
		(block inputVariables collect: [| :var | Syntax LoadVariable from: var])).
	opts
		ifNotNil:
		[message:
			((Syntax OptionalArguments for: message)
			`>> [arguments: (opts arguments deepCopy: block). ])].
	block statements: {message}.
	visitor visit:
		(Syntax KeywordMessage
		sending: #whenFulfilled:
		to: {def arguments as: Syntax Array. block})
].

visitor@(LLVM Visitor traits) visit: selector@(Symbol traits) on: args from: opts@(Syntax OptionalKeywords traits) [ 
"Generate the code to push the argument expression results on the stack, then
the push for the selector, and then the appropriate message send bytecode."
	args do: [| :arg | visitor visit: arg ].
	opts keywords with: opts arguments do: [
		| :key :arg |
		visitor visit: arg
	]
].

visitor@(LLVM Visitor traits) visit: opts@(Syntax OptionalKeywords traits) [
	visitor visit: opts message &optionals: opts
].

