Net define: #SocketLib
  &builder: [ExternalInterface newForLibrary: 'socket' primitives:
  #((Int Receive (Int Int Bytes Int))
    (Int Send (Int Int Bytes Int))
    (Int Close (Int))
    (Int Shutdown (Int Int))
    (Int GetHostByNameIp4 (CString Int Bytes))
    (Int SocketIp4Stream ())
    (Int ConnectIp4 (Int Int Int))
    (Int SetReuseAddr (Int Boolean))
    (Int BindIp4 (Int Int Int))
    (Int Listen (Int Int))
    (Int AcceptIp4 (Int Bytes Bytes))
    (Int SetNonBlocking (Int Boolean))
    (Int SetTcpNoDelay (Int Boolean))
    (Int GetSockError (Int))
    (Int HandleSetClear (Int))
    (Int HandleSetIncludes (Int Int))
    (Int HandleSetAdd (Int Int))
    (Int HandleSetRemove (Int Int))
    (Int Select (Int Int)))
  &leader: 'socket_'].

Net SocketLib ensureNamespace: #ErrorCodes.
Net SocketLib ErrorCodes `>> [
	       "Ideally, these would come from sys/errno.h somehow."
	       addImmutableSlot: #EINTR valued: 4.
	       addImmutableSlot: #EAGAIN valued: 35.
	       addImmutableSlot: #EINPROGRESS valued: 36.
             ].

Net SocketLib define: #SeriousCondition
  &parents: {Net Socket SeriousCondition}
  &slots: {#errno. #operation}.

sc@(Net SocketLib SeriousCondition traits) describeOn: out
[
  out
    ; 'Socket primitive failure with errno '
    ; sc errno printString
    ; ' during '
    ; sc operation printString
].

Net SocketLib define: #Mixin.

s@(Net SocketLib Mixin traits) signalErrno: e during: o
[Net SocketLib SeriousCondition new `>> [resource: s. errno: e. operation: o. signal]].

s@(Net SocketLib Mixin traits) checkError: block during: op &onBlock: waitBlock
[| result errno |
  [
    result: (block do).
    result isNegative ifFalse: [^ result].
    errno: result negated.
    errno = Net SocketLib ErrorCodes EINTR
      ifFalse: [errno = Net SocketLib ErrorCodes EAGAIN
                  ifTrue: [waitBlock ifNotNil: [waitBlock do]]
                  ifFalse: [s signalErrno: errno during: op]].
  ] loop.
].

s@(Net SocketLib Mixin traits) primitives
[Net SocketLib primitives].

s@(Net SocketLib Mixin traits) enable
[Net SocketLib enable].

s@(Net SocketLib Mixin traits) disable
[Net SocketLib disable].

s@(Net SocketLib Mixin traits) sessionDo: block
[ "TODO: fix this total bollocks"
  [ Net SocketLib enable.
    Net SocketLib library sessionDo: block
  ] ensure: [Net SocketLib disable]
].

"---------------------------------------------------------------------------"

Net define: #Ip4Socket &parents: {Net SocketLib Mixin. Net Socket}.

"---------------------------------------------------------------------------"

s@(Net Ip4Socket traits) enable
[
  resend.
  s handle: s createHandle.
  s checkError: [s primitives SetNonBlocking applyTo: {s handle. True}] during: #SetNonBlocking.
  s nativeSetup: s locator
].

s@(Net Ip4Socket traits) createHandle
[overrideThis].

s@(Net Ip4Socket traits) disable
[
  s checkError: [s primitives Close applyTo: {s handle}] during: #Close.
  resend.
].

"---------------------------------------------------------------------------"

Net define: #Tcp4Socket &parents: {Net Ip4Socket}.

s@(Net Tcp4Socket traits) createHandle
[
  s checkError: [s primitives SocketIp4Stream applyTo: {}] during: #SocketIp4Stream
].

s@(Net Tcp4Socket traits) nativeSetup: l@(Net Socket ConnectionTarget traits)
[
  s finishConnect: [s primitives ConnectIp4 applyTo: {s handle.
                                                      l endpoint address asIp4.
                                                      l endpoint port}].
  s
].

s@(Net Tcp4Socket traits) finishConnect: connectorBlock
[| err firstResult |
  [
    firstResult: connectorBlock do.
    firstResult negated = Net SocketLib ErrorCodes EINTR
  ] whileTrue.
  firstResult isZero ifTrue: [^ s]. "Initial connect call succeeded without delay."
  firstResult negated = Net SocketLib ErrorCodes EINPROGRESS
    ifFalse: [s signalErrno: firstResult negated during: #ConnectIp4].
  [
    Scheduler blockOn: s handle while: #connecting.
    err: (s checkError: [s primitives GetSockError applyTo: {s handle}] during: #GetSockError).
    err isZero ifTrue: [^ s]. "We're connected in this case."
    (err = Net SocketLib ErrorCodes EINPROGRESS)
  ] whileTrue.
  "If we reach here, there's some non-EINPROGRESS error condition on the socket."
  s signalErrno: err during: #finishConnect:
].

s@(Net Tcp4Socket traits) nativeSetup: l@(Net Socket ServiceAnchor traits)
[
  s checkError: [s primitives SetReuseAddr applyTo: {s handle. True}]
        during: #SetReuseAddr.
  s checkError: [s primitives BindIp4 applyTo: {s handle.
                                                s locator endpoint address asIp4.
                                                s locator endpoint port}]
        during: #BindIp4.
  s checkError: [s primitives Listen applyTo: {s handle. 0}]
        during: #Listen.
  s
].

s@(Net Tcp4Socket traits) accept
"Accepts an incoming connection, answering a new socket for communicating with the
requestor."
[| newHandle addrBytes portBytes |
  addrBytes: (ByteArray newSize: 4).
  portBytes: (ByteArray newSize: 2).
  newHandle: (s checkError: [s primitives AcceptIp4 applyTo: {s handle. addrBytes. portBytes}]
                    during: #AcceptIp4
                  &onBlock: [Scheduler blockOn: s handle while: #accepting]).
  s clone `>> [handle: newHandle. ] "TODO: store the address/port of the remote end somewhere"
].

s@(Net Tcp4Socket traits) read: n from: handle into: array startingAt: start
"The primitive for external input: read N bytes from the resource's handle
at the given start position, placing them in the array (starting at 0)."
[| sofar pos |
  sofar: 0.
  [sofar < n]
    whileTrue:
      [| nread |
       nread: (s checkError: [s primitives Receive applyTo: {n. handle. array. start + sofar}]
                     during: #Receive
                   &onBlock: [Scheduler blockOn: handle while: #reading]).
       nread isZero ifTrue: [^ sofar]. "TODO: eof detection"
       sofar: (sofar + nread)].
  sofar
].

s@(Net Tcp4Socket traits) write: n to: handle from: array startingAt: start
"The primitive for external output: write N bytes to the resource's handle
at the given start position, taking them from the array (starting at 0)."
[| sofar pos |
  sofar: 0.
  [sofar < n]
    whileTrue:
      [| nwritten |
       nwritten: (s checkError: [s primitives Send applyTo: {n. handle. array. start + sofar}]
                        during: #Send
                      &onBlock: [Scheduler blockOn: handle while: #writing]).
       "TODO: eof detection?"
       sofar: (sofar + nwritten)].
  sofar
].

s@(Net Tcp4Socket traits) setTcpNoDelay &to: b
[
  s checkError: [s primitives SetTcpNoDelay applyTo: {s handle. b ifNil: [True]}]
        during: #SetTcpNoDelay
].

s@(Net Tcp4Socket traits) newNamed: loc
[
  s clone `>> [locator: loc. ]
].

"---------------------------------------------------------------------------"

Net define: #DNSAddress &parents: {Net SocketLib Mixin} &slots: {#hostname}.

"This is a crappy implementation delegating to the libc resolver.
A better implementation would implement the DNS protocol directly in Slate,
atop a UDP socket. That way, proper nonblocking behaviour can be assured."

d@(Net DNSAddress traits) forHostname: h
[
  d clone `>> [hostname: h. ]
].

d@(Net DNSAddress traits) asIp4
[| addr |
  d sessionDo: [|:lib|
    addr: (ByteArray newSize: 4).
    (d checkError: [d primitives GetHostByNameIp4 applyTo: {d hostname. d hostname length. addr}]
           during: #GetHostByNameIp4)
      isZero ifTrue: [error: ('gethostbyname failed for ' ; d hostname)].
    (addr as: BigInteger) shrunkToFit]
].

"---------------------------------------------------------------------------"

"
Sockets and image startup/shutdown.

Server sockets: should reconnect.
Client sockets: probably shouldn't reconnect.
Actually, you could vary the locator for that.

The multiplexor: There Must Only Be One

The external library: There Should Only Be One
 and it should be opened at image startup
 and closed at image shutdown
 and it must be open by the time the multiplexor needs it
"

Net define: #Multiplexor
  &parents: {Net SocketLib Mixin. ExternalResource} "TODO: Make this an oddball somehow"
  &slots: {#readers -> Dictionary new.
           #writers -> Dictionary new}.

m@(Net Multiplexor traits) addProcess: proc toMap: dict for: fd
[
  (dict at: fd ifAbsentPut: [Queue new]) addLast: proc.
].

m@(Net Multiplexor traits) addFd: fd toSet: s
[
  Console ; 'About to poll ' ; fd printString ; ' in set ' ; s printString ; '\n'.
  m primitives HandleSetAdd applyTo: {s. fd}.
].

m@(Net Multiplexor traits) set: s hasActiveFd: fd
[| r |
  r: (m primitives HandleSetIncludes applyTo: {s. fd}).
  r isNegative ifTrue: [error: 'Negative result in HandleSetIncludes!'].
  r isZero not
].

m@(Net Multiplexor traits) unblockProcessFrom: q for: fd ifActiveIn: s
[
  (m set: s hasActiveFd: fd) ifFalse: [^ Nil].
  q isEmpty ifTrue: [^ Nil].
  Console ; 'Unblocking ' ; fd printString ; ' from set ' ; s printString ; '\n'.
  Scheduler unblock: q removeFirst.
].

m@(Net Multiplexor traits) prepareHandleSets
[| maxfd |
  maxfd: -1.
  (0 below: 3) do: [|:i| (Net Ip4Socket primitives HandleSetClear applyTo: {i})].
  m readers keysDo: [|:fd| m addFd: fd toSet: 0. fd > maxfd ifTrue: [maxfd: fd]].
  m writers keysDo: [|:fd| m addFd: fd toSet: 1. fd > maxfd ifTrue: [maxfd: fd]].
  maxfd
].

m@(Net Multiplexor traits) scanHandleSets
[
  m readers keysAndValuesDo: [|:fd :q| m unblockProcessFrom: q for: fd ifActiveIn: 0].
  m writers keysAndValuesDo: [|:fd :q| m unblockProcessFrom: q for: fd ifActiveIn: 1].
].

m@(Net Multiplexor traits) mainLoopBody
[| maxfd timeoutmillis r |
  timeoutmillis: 100. "TODO: Implement a timeout heap"
  maxfd: m prepareHandleSets.
  r: (m checkError: [m primitives Select applyTo: {maxfd + 1. timeoutmillis}]
	    during: #Select).
  Console ; 'Woke up\n'.
  r isZero ifFalse: [ m scanHandleSets ].
  "TODO: deal with set 2, the error set"
  Scheduler yield.
].

m@(Net Multiplexor traits) mainLoop
[| maxfd timeoutmillis r |
  m enable. "TODO: Fix this"
  [ m mainLoopBody ] loop.
].

s@(processes Scheduler) blockOn: fd@(Integer traits) while: event@(Symbol traits)
[| m d |
  m: Net Multiplexor.
  d: (event caseOf: {
        #reading -> [m readers].
        #writing -> [m writers].
        #accepting -> [m readers].
        #connecting -> [m writers].
      }).
  SuspendedProcess createAndDo: [|:proc| m addProcess: proc toMap: d for: fd]
].
