define: #OrderedDictionary &parents: {ExtensibleSequence. Mapping} &slots: {
  #keys -> (ExtensibleArray newSize: 10).
  #values -> (ExtensibleArray newSize: 10)
}.

d@(OrderedDictionary traits) size
[d keys size].

d@(OrderedDictionary traits) capacity
[d keys capacity].

d@(OrderedDictionary traits) copy
[resend `>> [keys := d keys copy. values := d values copy. ]].

d@(OrderedDictionary traits) new &capacity: n
[
  n `defaultsTo: 0.
  resend `>>
    [keys := d keys new &capacity: n.
     values := d values new &capacity: n. ]
].

d@(OrderedDictionary traits) newFrom: keys@(Sequence traits) to: values@(Sequence traits)
[
  result ::= d new.
  result keys := keys as: result keys.
  result values := values as: result values.
  result
].

d@(OrderedDictionary traits) acceptsKey: key
[d keys accepts: key].

d@(OrderedDictionary traits) = e@(OrderedDictionary traits)
[
  d == e
    \/ [d size = e size
	  /\ [d keysAndValuesDo:
	        [| :key :value |
		 (e at: key ifAbsent: [^ False]) = value ifFalse: [^ False]].
	      True]]
].

d@(OrderedDictionary traits) clear
[
  d keys clear.
  d values clear.
  d
].

d@(OrderedDictionary traits) includes: obj
[
  d values includes: obj
].

d@(OrderedDictionary traits) includesIdentity: obj
[
  (d values detect: [| :each | obj == each]) isNotNil
].

d@(OrderedDictionary traits) includesKey: obj
[
  d keys includes: obj
].

d@(OrderedDictionary traits) keySet
[
  d keys as: Set
].

d@(OrderedDictionary traits) valueSet
[
  d values as: Set
].

d@(Dictionary traits) occurrencesOf: obj
"The number of indexed values equal to obj."
[| count |
  count := 0.
  d do: [| :each | (d equalsBlock apply*, obj, each)
    ifTrue: [count += 1]].
  count
].

d@(Dictionary traits) addAll: map@(Mapping traits)
"Adds all of the key-value pairs to the Dictionary. Notice that this works
for any Mapping, but that other collections will not do."
[
  d == map ifFalse:
    [map keysAndValuesDo: #(d at: _ put: _) `er].
  map
].

d@(OrderedDictionary traits) addAll: seq@(Sequence traits)
[
  seq doWithIndex: [| :assoc :index |
    (assoc isSameAs: Association)
      ifTrue: [d add: assoc]
      ifFalse: [d at: index put: assoc]].
  seq
].

d@(OrderedDictionary traits) declare: key from: e@(Mapping traits)
"Add key to d, unless the key already exists. Remove key from e
and move its association to d."
[
  (d includesKey: key) ifFalse:
    [(e includesKey: key)
       ifTrue: [d add: (e associationAt: key).
                e removeKey: key]
       ifFalse: [d add: key -> Nil]].
  d
].

d@(Dictionary traits) associationAt: key ifAbsent: block
[
  (d contents at: (index ::= d scanFor: key))
    ifNil: [block do]
    ifNotNil: [(d contents at: index) -> (d values at: index)]
].

d@(Dictionary traits) associationAt: key
[
  d associationAt: key ifAbsent: [key keyNotFoundOn: d]
].

d@(Dictionary traits) at: key ifAbsent: block
[
  (d contents at: (index ::= d scanFor: key))
    ifNil: [block do]
    ifNotNil: [d values at: index]
].

d@(OrderedDictionary traits) add: assoc@(Association traits)
"Adds a new key value pair to the OrderedDictionary from an assocation.
For example: OrderedDictionary new `>> [ add: 'first' -> 'Joe Henry'. ]."
[
  d at: assoc key put: assoc value.
  assoc
].

d@(OrderedDictionary traits) at: key put: obj
[
  (d keys indexOf: key)
    ifNil:
      [d keys addLast: key.
       d values addLast: obj]
    ifNotNilDo: [| :index | d values at: index put: obj]
].

d@(Dictionary traits) keyAtValue: obj ifAbsent: block
[
  d keysAndValuesDo: [| :key :value |
      (d equalsBlock apply*, obj, value) ifTrue: [^ key]].
  block do
].

d@(Dictionary traits) keyAtIdentityValue: obj ifAbsent: block
[
  d values doWithIndex: [| :each :index | each == obj
    ifTrue: [^ (d contents at: index)]].
  block do
].

d@(Dictionary traits) keyAtIdentityValue: obj
[
  d keyAtIdentityValue: obj ifAbsent: [obj elementNotFoundOn: d]
].

d@(OrderedDictionary traits) keysAndValuesDo: block
[
  d keys with: d values do: [| :key :value | block apply*, key, value]
].

d@(OrderedDictionary traits) keysDo: block
[
  d keys do: block
].

d@(OrderedDictionary traits) valuesDo: block
[
  d values do: block
].

d@(Dictionary traits) keysAndValuesRemove: block
"Removes key-value pairs that satisfy the two-argument block."
[
  removals ::= ExtensibleArray new.
  d keysAndValuesDo: [| :key :value | (block apply*, key, value)
      ifTrue: [removals add: key]].
  removals do: #(d removeKey: _) `er.
  d
].

d@(Dictionary traits) removeKey: key ifAbsent: block
[
  (index ::= d scanFor: key)
    ifNil: [^ block do].
  value ::= d contents at: index.
  d contents at: index put: Nil.
  d values at: index put: Nil.
  d tally -= 1.
  d fixCollisionsFrom: index.
  value
].

d@(Dictionary traits) removeKey: key
[
  d removeKey: key ifAbsent: [key keyNotFoundOn: d]
].

d@(Dictionary traits) remove: key
[
  d removeKey: key
].

d@(Dictionary traits) remove: key ifAbsent: block
[
  d removeKey: key ifAbsent: block
].

d@(Dictionary traits) associationsDo: block
[
  d isEmpty ifFalse:
    [d contents doWithIndex:
       [| :each :index | each ifNotNil:
          [block apply*, (each -> (d values at: index))]]]
].

d@(Dictionary traits) do: block
"Applies a single-argument block to each keyed value in the Dictionary.
Equivalent to valuesDo:."
[d valuesDo: block].

d mapSelect: block into: result@(Dictionary traits)
"Filter the dictionary by values satisfying a block."
[d keysAndValuesDo:
  [| :key :value | (block apply*, key, value)
      ifTrue: [result noCheckAt: key put: value]].
  result
].

d select: block into: result@(Dictionary traits)
[d mapSelect: [| :_ :value | block apply*, each] into: result].
  
d@(Dictionary traits) collect: block
"Generate a new collection based on applying the block to each value."
[
  result ::= ExtensibleArray new.
  d do: [| :each | result add: (block apply*, each)].
  result
].

d@(Dictionary traits) swap: index1 with: index2
[
  d contents swap: index1 with: index2.
  d values swap: index1 with: index2.
  d
].

d@(Dictionary traits) noCheckAt: key put: value
[
  index ::= d scanFor: key.
  d contents at: index put: key.
  d values at: index put: value.
  d tally += 1.
].

d@(Dictionary traits) noCheckAdd: assoc
[
  d noCheckAt: assoc key put: assoc value
].

d@(Dictionary traits) growBy: growthAmount
[
  tempDict ::= d new &capacity: d contents size + growthAmount.
  d keysAndValuesDo: #(tempDict noCheckAt: _ put: _) `er.
  d contents := tempDict contents.
  d values := tempDict values.
  d
].

d@(Dictionary traits) rehash
[
  tempDict ::= d newSameSize.
  d keysAndValuesDo: #(tempDict noCheckAt: _ put: _) `er.
  d contents := tempDict contents.
  d values := tempDict values.
  d
].

d@(Dictionary traits) scanFor: obj
"Scans the key array for the first empty slot or an element matching the
object. Returns the index at which the object is used as a key, or Nil if
it's not found and the Dictionary is full."
[| key |
  end ::= d contents size.
  start ::= ((d hashBlock apply*, obj) \\ end) + 1.
  block ::=
    [| :index |
     (key := d contents at: index) isNil \/
       [d equalsBlock apply*, obj, key]
       ifTrue: [^ index]].
  start below: end do: block.
  0 below: start do: block.
  Nil
].
