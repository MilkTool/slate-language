
s@(String traits) interpolate
"Interpolates arguments formatted as '{N}' with corresponding elements from
an array argument. Curly open-brackets may be escaped by doubling them."
"Test: ('{{ } \\ foo {0} bar {1}' interpolate, 12, 'string') = '{ } \ foo 12 bar string'"
[| *args index |
  input ::= s reader.
  [| :result |
   input do:
     [| :char |
      char == $\{
	ifTrue:
	  [input peek == $\{
	     ifTrue: [result nextPut: input next]
	     ifFalse: [index := Integer readFrom: (input upTo: $\}).
		       result ; ((args at: index ifAbsent: ['[subscript out of bounds: {0}]' interpolate, index]) as: s)]]
	ifFalse: [result nextPut: char]].
   ] writingAs: s
].

s@(String traits) formatting
[| *args input argsIndex nextChar |
  input := s reader.
  argsIndex := args indexFirst.
  [| :result |
   input do:
     [| :char |
      char == $%
        ifTrue: "Placeholder"
          [(nextChar := input next) == $%
             ifTrue: [result nextPut: nextChar]
             ifFalse:
               [| arg argPosition specifier width precision position alternative plus minus star align padChar |
                argPosition := input position.
                input skip: -1.
                padChar := $\s.
                specifier := (input upToAnyOf: 'diueEfFgGxXoscpn') reader.
                [specifier isAtEnd] whileFalse:
                  [nextChar := specifier next.
                   "Check for a parameter index spec:"
                   ('123456789' includes: nextChar)
                     ifTrue:
                       [(specifier peek: 1) == $$
                          ifTrue:
                            [specifier skip: -1.
                             position := Integer readFrom: specifier.
                             specifier next]
                          ifFalse:
                            [specifier skip: -1.
                             width := Integer readFrom: specifier]]
                     ifFalse: "Check for flags:"
                       [nextChar caseOf: {
                          $\s -> [padChar := nextChar].
                          $#  -> [alternative := True].
                          $+  -> [plus := True].
                          $-  -> [minus := True].
                          $0  -> [padChar := $0].
                          $*  -> [star := True].
                          $<  -> [align := #left].
                          $>  -> [align := #right].
                          $=  -> [align := #center].
                          $.  -> [precision := Integer readFrom: specifier]
                        } otherwise: [inform: nextChar printString]]].
                input position := argPosition.
                input upToAnyOf: 'diueEfFgGxXoscpn'. input skip: -1.
                "Check for type specifiers:"
                position ifNil:
                  [position := argsIndex.
                   argsIndex += 1].
                width isNil /\ [star isNotNil] ifTrue:
                  [width := args at: position.
                   position += 1.
                   argsIndex += 1].
                arg := args at: position.
                arg := (nextChar := input next) toLowercase caseOf: {
                  $r -> [arg printString].
                  $@ -> [arg printString].
                  $s -> [arg as: s].
                  $c -> [arg as: s]. "Character"
                  $d -> [arg printString &radix: 10 &precision: precision &forceSign: plus isNotNil].
                  $i -> [arg printString &radix: 10 &precision: precision &forceSign: plus isNotNil].
                  $u -> [arg printString &radix: 10 &precision: precision &forceSign: plus isNotNil].
                  $b -> [arg printString &radix: 2  &precision: precision &forceSign: plus isNotNil].
                  $o -> [arg printString &radix: 8  &precision: precision &forceSign: plus isNotNil].
                  $x -> [arg printString &radix: 16 &precision: precision &forceSign: plus isNotNil].
                  $f -> [arg printString &precision: precision &forceSign: plus isNotNil].
                  $e -> [arg printString &precision: precision &forceSign: plus isNotNil].
                } otherwise: [arg as: s].
                nextChar isUppercase ifTrue: [arg toUppercase].
                width ifNotNil:
                  [minus isNotNil /\ [align isNil] ifTrue: [align := #right].
                   arg := align caseOf: {
                     #left -> [arg truncateTo: width paddedBy: padChar &onRight: False].
                     #right -> [arg truncateTo: width paddedBy: padChar &onRight: True].
                     #center -> [(arg truncateTo: width + arg size // 2 paddedBy: padChar &onRight: False)
                                   truncateTo: width paddedBy: padChar &onRight: True]
                   } otherwise: [arg truncateTo: width paddedBy: padChar &onRight: False]].
                result ; arg]]
        ifFalse: [result nextPut: char]]
  ] writingAs: s
].
