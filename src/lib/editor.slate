"a line editor for src/ui/textbox.slate"

prototypes ensureNamespace: #Editor &delegate: True.


Editor define: #Cursor &parents: {Cloneable} &slots: {#line -> 0. #column -> 0}.
Editor define: #Line &parents: {Cloneable} &slots: {#contents -> ''}.
Editor define: #EditorAction &parents: {Cloneable} &slots: {#redo -> Nil. #undo -> Nil}.

Editor define: #LineEditor &parents: {Cloneable}
  &slots: {#lines -> ExtensibleArray new. 
           #cursors -> Stack new.
           "when the cursor moves these may be updated... they help decide what needs to be painted"
           #firstVisibleLine -> 0.
           #visibleLines -> 10.
           #undoHistory -> ExtensibleArray new.
           #undoHistoryPosition -> 0.
           }.


x@(LineEditor traits) new
[ |le|
  le: resend.
  le lines addLast: Line new.
  le cursors push: (Cursor line: 0 column: 0).
  le
].

le@(LineEditor traits) cursor
["return the current cursor point"
  le cursors top
].

c@(Cursor traits) line: line column: column
[
  c cloneSettingSlots: #(line column) to: {line. column}
].

ea@(EditorAction traits) redo: redo undo: undo
[
  ea cloneSettingSlots: #(redo undo) to: {redo. undo}
].

"------------------------------------------------------------"
"functions that you can replace if you change the underlying data types. all functions on the buffer
should use these functions instead of accessing the lines directly. these should NOT modify the cursor point"
"------------------------------------------------------------"

l@(Line traits) size [l contents size].
l@(Line traits) first: n [l contents first: n].
l@(Line traits) allButFirst: n [l contents allButFirst: n].
l@(Line traits) merge: l2@(Line traits) [l contents: l contents ; l2 contents].
l@(Line traits) as: _@(String traits) [l contents].

l@(Line traits) deleteAt: n
[
  l contents: (l first: n) ; (l allButFirst: n + 1).
  l
].

l@(Line traits) insert: c at: n
[
  l contents: (l first: n) ; (c as: String) ; (l allButFirst: n).
  l
].

le@(LineEditor traits) lineCount [le lines size].

le@(LineEditor traits) lineAt: line
[
  le lines at: line
].

le@(LineEditor traits) textOnLineAfter: c@(Cursor traits)
["this includes the point"
  (le lineAt: c line) allButFirst: c column
].

le@(LineEditor traits) textOnLineBefore: c@(Cursor traits)
[
  (le lineAt: c line) first: c column
].

le@(LineEditor traits) deleteFrom: c@(Cursor traits)
[
  (le lineAt: c line) deleteAt: c column.
].

le@(LineEditor traits) characterAt: c@(Cursor traits)
[ |line|
  line: (le lineAt: c line).
  line contents size <= c column ifTrue: [line contents size = 0
                                               ifTrue: [^ (line contents at: line contents size - 1)]
                                               ifFalse: [^ $\n]].
  line contents at: c column
].


le@(LineEditor traits) insertCharacter: c@(ASCIICharacter traits) at: point@(Cursor traits)
[
  (le lineAt: point line) insert: c at: point column.
].


le@(LineEditor traits) setTextOnLine: line to: s
[
  (le lineAt: line) contents: s
].

le@(LineEditor traits) insertLineAt: line withText: s
[
  le lines at: line insert: (Line new `>> [contents: s. ]).
].

le@(LineEditor traits) breakLine: line at: column
[ |restOfLine p |
  p: (Cursor line: line column: column).
  restOfLine: (le textOnLineAfter: p).
  le insertLineAt: line withText: (le textOnLineBefore: p).
  le setTextOnLine: line + 1 to: restOfLine.
].

le@(LineEditor traits) mergeLine: line with: line2
[
  (le lineAt: line) merge: (le lineAt: line2).
   le deleteLine: line2.
].

le@(LineEditor traits) deleteLine: line
[
  le lines at: line remove: 1
].

p@(Cursor traits) forwardOn: le@(LineEditor traits)
[ |point|
  point: p copy. 
  (le lineAt: point line) size > point column ifTrue: [point column: point column + 1. ^ point].
  le lineCount <= (point line + 1) ifTrue: [inform: 'End of buffer'. ^ point].
  point line: point line + 1.
  point column: 0.
  point
].

p@(Cursor traits) forwardOnSameLine: le@(LineEditor traits)
[ |point|
  point: p copy. 
  (le lineAt: point line) size > point column ifTrue: [point column: point column + 1. ^ point].
  point
].

p@(Cursor traits) backwardOn: le@(LineEditor traits)
[ |point|
  point: p copy.
  point column > 0 ifTrue: [point column: point column - 1. ^ point].
  point line < 1 ifTrue: [inform: 'Beginning of buffer'. ^ point].
  point line: point line - 1.
  point column: (le lineAt: point line) size.
  point
].

p@(Cursor traits) nextLineOn: le@(LineEditor traits)
[ |point|
  point: p copy.
  point line: (point line + 1 min: le lineCount).
  point
].

p@(Cursor traits) previousLineOn: le@(LineEditor traits)
[ |point|
  point: p copy.
  point line: (point line - 1 max: 0).
  point

].


p@(Cursor traits) setTo: point@(Cursor traits)
[
  p line: point line.
  p column: point column.
  p
].

le@(LineEditor traits) do: block undo: undoBlock record: record
[ | undoFromEnd |
  record `defaultsTo: True.
  record ifFalse: [^ block do].
  undoFromEnd: le undoHistory size - le undoHistoryPosition.
  undoFromEnd > 0 ifTrue: [le undoHistory removeLast: undoFromEnd].

  "fixme: perhaps catch errors from doing the block and altering undo history?"
  le undoHistoryPosition: le undoHistoryPosition + 1.
  le undoHistory addLast: (EditorAction redo: block undo: undoBlock).
  block do
  
].

le@(LineEditor traits) undo
[
  le undoHistoryPosition < 1 ifTrue: [^ Nil].
  le undoHistoryPosition: le undoHistoryPosition - 1.
  (le undoHistory at: le undoHistoryPosition) undo do.
].

le@(LineEditor traits) redo
[
  le undoHistoryPosition >= le undoHistory size ifTrue: [^ Nil].
  (le undoHistory at: le undoHistoryPosition) redo do.
  le undoHistoryPosition: le undoHistoryPosition + 1.
].


"------------------------------------------------------------"
"functions here use the functions above to modify the buffer.
these functions will create undo history and have side effects
on the point.

record -> should this be recorded in the undo history?"
"------------------------------------------------------------"

"fixme use forward on same line and stuff"

le@(LineEditor traits) insert: s@(ASCIIString traits) at: point@(Cursor traits) &record: record
[ "fixme this creates a lot of undo history"
  s do: [|:c| le insert: c at: point].
].

le@(LineEditor traits) insert: c@(ASCIICharacter traits) at: point@(Cursor traits) &record: record
[ | p |
  p: point copy. "make a copy so the undo history doesn't get one with side effects"
  c = $\r ifTrue: [
                    le do: [le breakLine: p line at: p column.
                            point setTo: (p forwardOn: le)]
                       undo: [le deleteFrom: p. 
                              point setTo: p]
                       record: record]
           ifFalse: [le do: [le insertCharacter: c at: p.
                             point setTo: (p forwardOnSameLine: le)]
                        undo: [le deleteFrom: p.
                               point setTo: p]
                        record: record].

].


le@(LineEditor traits) deleteBackwardAt: point@(Cursor traits) &record: record
[ | deletedCharacter p prevLineSize|
  p: point copy. "make a copy so the undo history doesn't get one with side effects"
  p column < 1 ifTrue: [p line = 0 ifTrue: [inform: 'Cannot delete beginning of buffer'. ^ Nil].
                        prevLineSize: (le lineAt: point line - 1) size.
                        le do: [point setTo: (p backwardOn: le).
                                le mergeLine: p line - 1 with: p line]
                           undo: [le breakLine: p line - 1 at: prevLineSize.
                                  point setTo: p]
                          record: record]
               ifFalse: [deletedCharacter: (le characterAt: (p backwardOn: le)).
                         inform: 'deleted: ' ; deletedCharacter printString.
                         le do: [le deleteFrom: (p backwardOn: le).
                                 point setTo: (p backwardOn: le)]
                            undo: [le insertCharacter: deletedCharacter at: (p backwardOn: le).
                                   point setTo: p]
                            record: record].

].

"fixme: deleteFrom name might be confused with this"
le@(LineEditor traits) deleteAt: point@(Cursor traits) &record: record
[ | deletedCharacter p lineSize|
  p: point copy. "make a copy so the undo history doesn't get one with side effects"
  p column >= (le lineAt: p line) size
    ifTrue: [p line + 1 >= le lineCount ifTrue: [inform: 'Cannot delete end of buffer'. ^ Nil].
             lineSize: (le lineAt: point line) size.
             le do: [le mergeLine: p line with: p line + 1.
                     point setTo: p]
                undo: [le breakLine: p line at: lineSize.
                       point setTo: p]
                record: record]
    ifFalse: [deletedCharacter: (le characterAt: p).
              inform: 'deleted: ' ; deletedCharacter printString.
              le do: [le deleteFrom: p.
                      point setTo: p]
                 undo: [le insertCharacter: deletedCharacter at: p.
                        point setTo: p]
                 record: record].
  
].
