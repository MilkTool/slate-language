lobby ensureNamespace: #Regex.
Regex ensureNamespace: #Syntax.
Regex ensureNamespace: #Token.
Regex ensureNamespace: #Match.

"counter is incremented and stored inside expressions"
Regex define: #Parser &parents: {Cloneable} &slots: {#position. #source. #counter}.
Regex define: #Regex &parents: {Cloneable} &slots: {#regex. #parser -> Regex Parser.}.


"nodes are output by the parser"
Regex Syntax define: #Node &parents: {Cloneable}.


"the top element with expressions surrounded by branches 'exp|exp'"
Regex Syntax define: #Branch &parents: {Regex Syntax Node} &slots: {#expressions}.

"must match in consecutive order 'ab'"
Regex Syntax define: #Expression &parents: {Regex Syntax Node} &slots: {#term. #counter. #repeatCount -> (1 to: 1 by: 1)}.


"'[abc]'"
Regex Syntax define: #CharacterGroup &parents: {Regex Syntax Node} &slots: {#negated -> False. #elements -> ExtensibleArray new}.
"'a'"
Regex Syntax define: #Character &parents: {Regex Syntax Node} &slots: {#character}.
"'a-z'"
Regex Syntax define: #CharacterRange &parents: {Regex Syntax Node} &slots: {#start. #end}.


Regex Match define: #Terminator &parents: {Cloneable}.


r@(Regex Syntax Character traits) newOn: c
[
  r new `>> [character: c. ]
].


Regex Parser traits define: #BackslashSpecials -> Dictionary new.

{
$e -> (Regex Syntax Character newOn: $\e).
$n -> (Regex Syntax Character newOn: $\n).
$r -> (Regex Syntax Character newOn: $\r).
$f -> (Regex Syntax Character newOn: $\f).
$t -> (Regex Syntax Character newOn: $\t).
$w -> (Regex Syntax CharacterGroup new `>> [elements: {(Regex Syntax CharacterRange new `>> [start: $A. end: $Z.]).
                                              (Regex Syntax CharacterRange new `>> [start: $a. end: $z.]).
                                              (Regex Syntax CharacterRange new `>> [start: $0. end: $9.]).
                                              (Regex Syntax Character newOn: $_).}.]).
$W -> (Regex Syntax CharacterGroup new `>> [elements: {(Regex Syntax CharacterRange new `>> [start: $A. end: $Z.]).
                                              (Regex Syntax CharacterRange new `>> [start: $a. end: $z.]).
                                              (Regex Syntax CharacterRange new `>> [start: $0. end: $9.]).
                                              (Regex Syntax Character newOn: $_).}.
                                   negated: True. ]).
$s -> (Regex Syntax CharacterGroup new `>> [elements: {(Regex Syntax Character newOn: $\e).
                                              (Regex Syntax Character newOn: $\n).
                                              (Regex Syntax Character newOn: $\r).
                                              (Regex Syntax Character newOn: $\f).
                                              (Regex Syntax Character newOn: $\t).}.]).
$s -> (Regex Syntax CharacterGroup new `>> [elements: {(Regex Syntax Character newOn: $\e).
                                              (Regex Syntax Character newOn: $\n).
                                              (Regex Syntax Character newOn: $\r).
                                              (Regex Syntax Character newOn: $\f).
                                              (Regex Syntax Character newOn: $\t).}.
                                   negated: True.]).
$d -> (Regex Syntax CharacterGroup new `>> [elements: {(Regex Syntax CharacterRange new `>> [start: $0. end: $9.])}.]).
$D -> (Regex Syntax CharacterGroup new `>> [elements: {(Regex Syntax CharacterRange new `>> [start: $0. end: $9.])}.
                                   negated: True.]).

} do: [ |:each | Regex Parser BackslashSpecials at: each key put: each value].


r@(Regex Regex traits) newOn: s@(String traits)
[ | re |
  re: r new.
  re parser: (r parser newOn: s).
  re regex: re parser parse.
  re
].


rp@(Regex Parser traits) newOn: s@(String traits)
[ | obj |
  obj: rp new.
  obj source: s.
  obj position: 0.
  obj counter: 0.
  obj
].

p@(Regex Parser traits) next
[ |obj|
  p position >= p source size ifTrue: [p position: p position + 1. ^ Nil].
  obj: (p source at: p position).
  p position: p position + 1.
  obj
].

p@(Regex Parser traits) previous
[
  p position: p position - 1.
].

p@(Regex Parser traits) expected: x butFound: y
[
  error: 'Parser expected ' ; x printString ; ' but found ' ; y printString.
].

p@(Regex Parser traits) parse
[
  p parseBranch
].

p@(Regex Parser traits) nextAssertIs: item
[ |next|
  next: p next.
  next = item ifFalse: [p expected: item butFound: next].
].

p@(Regex Parser traits) backspaceCharacterFor: c
[
  Regex Parser BackslashSpecials at: c
].

"branch ::= expression* 
          | branch '|' branch"

p@(Regex Parser traits) parseBranch
[ | obj next |
  obj: p parseExpression.
  next: p next.
  next caseOf:
    { Nil -> [^ obj].
      $| -> ["[next: p next. next = $]] whileFalse: [p parseRange ifNotNilDo: [|:r| obj elements addLast: r]]"
                ]}
   otherwise: [p expected: {Nil. $|} butFound: next]

].
"repeatcount ::= {m,n}"

p@(Regex Parser traits) parseRepeatCount
[
  error: 'fixme'.
].

"expression ::= term | term '?' | term '+' | term '*' | term numericrange"
p@(Regex Parser traits) parseExpression
[ | obj next |
  obj: p parseTerm.
  next: p next.
  next caseOf:
    { $? -> [obj repeatCount: (0 to: 1 by: 1). ^ obj].
      $+ -> [obj repeatCount: (1 to: PositiveInfinity by: 1). ^ obj].
      $* -> [obj repeatCount: (0 to: PositiveInfinity by: 1). ^ obj].
      ${ -> [obj repeatCount: p parseRepeatCount. p nextAssertIs: $}. ^ obj].
      }
   otherwise: [p previous. ^ obj]

].

"term ::= group | '(' branch ')"
p@(Regex Parser traits) parseTerm
[ | next obj count |
  next: p next.
  next caseOf:
    { $( -> [p previous.
             count: p counter. 
             p counter: p counter + 1.
             obj: p parseExpression. 
             obj counter: count.
             p nextAssertIs: $). 
             ^ obj].
      }
   otherwise: [p previous. ^ p parseGroup]

].

"group ::= symbol | '[' '^'? range* ']'"
p@(Regex Parser traits) parseGroup
[ | next obj |
  next: p next.
  next = $[
   ifTrue: [obj: Regex Syntax CharacterGroup new `>> [elements: ExtensibleArray new. ].
            next: p next.
            next = $^ ifTrue: [obj negated: True] ifFalse: [p previous].
            [next: p next. next = $]] whileFalse: [p parseRange ifNotNilDo: [|:r| obj elements addLast: r]].
            ^ obj]
   ifFalse: [p previous. ^ p parseSymbol]

].

"range ::= symbol | symbol '-' symbol"
p@(Regex Parser traits) parseRange
[ | next start end obj |
  start: p parseSymbol.
  next: p next.
  next = $] ifTrue: [p previous. ^ Nil]. "fix return value?"
  next = $-
   ifTrue: [end: p parseSymbol.
            obj: Regex Syntax CharacterRange new `>> [start: start. end: end. ].
            next: p next.
            next = $^ ifTrue: [obj negated: True] ifFalse: [p previous].
            [next: p next. next = $]] whileFalse: [obj elements addLast: p parseRange].
            ^ obj]
   ifFalse: [p previous. ^ p parseSymbol]

].

"symbol ::= . | char | escape char"
p@(Regex Parser traits) parseSymbol
[ | next |
  next: p next.
  next = $. ifTrue: [^ Regex Syntax CharacterRange new `>> [start: start. end: end. ]].
  next = $\\
   ifTrue: [next: p next.
            p backspaceCharacterFor: next]
   ifFalse: [Regex Syntax Character new `>> [character: next. ]]

].
