

"Slate based sockets"

prototypes ensureNamespace: #networking &delegate: True.

networking define: #Socket &parents: {Cloneable} &slots: {#fd -> Nil}.
networking define: #SocketServerConnection &parents: {Socket} &slots: {#peerAddress -> Nil}.
networking define: #SocketAddress &parents: {Cloneable} &slots: {#address -> Nil}.
networking define: #IP4Address &parents: {SocketAddress}.
networking define: #UnixDomainAddress &parents: {SocketAddress}.

networking define: #SocketServer &parents: {Cloneable}
 &slots: {#pipeToLoop -> Nil. #ip -> Nil. #port -> Nil. #dispatch -> Nil}.


Socket traits ensureNamespace: #ErrorCodes.
Socket traits ensureNamespace: #Domains.
Socket traits ensureNamespace: #Types.
Socket traits ensureNamespace: #Protocols.
Socket traits addSlot: #SelectTimeout valued: lobby timeSinceEpoch.
Socket traits addSlot: #BufferSize valued: 1024.

Socket ErrorCodes addSlot: #Dictionary valued: Dictionary new.

{

  #Error -> -1.
  #AccessDenied -> -2.
  #NoSupport -> -3.
  #Invalid -> -4.
  #Overflow -> -5.
  #NoMemory -> -6.
  #InUse -> -7.
  #BadFD -> -8.
  #Again -> -9.
  #WouldBlock -> -10.
  #ConnectionAborted -> -11.
  #Interrupted -> -12.
  #AlreadyInProgress -> -13.
  #ConnectionRefused -> -14.
  #InProgress -> -15.
  #AlreadyConnected -> -16.
  #NetworkUnreachable -> -17.
  #Timeout -> -18.

} do: [ | :item | 
         Socket ErrorCodes addImmutableSlot: item key valued: item value.
         Socket ErrorCodes Dictionary add: item value -> item key.
       ].



Socket Domains `>> [
  addImmutableSlot: #Local valued: 1.
  addImmutableSlot: #IP4 valued: 2.
  addImmutableSlot: #IP6 valued: 3.
  ].

Socket Types `>> [
  addImmutableSlot: #Stream valued: 1.
  ].

Socket Protocols `>> [
  addImmutableSlot: #Default valued: 0.
  ].


s@(Socket traits) throwError: code
[
  error: (Socket ErrorCodes Dictionary at: code) printString
].


s@(Socket traits) newFor: domain type: type protocol: proto
[ | ret |
  ret: s new.
  ret fd: (domain socketCreate: type protocol: proto).
  ret fd < 0 ifTrue: [s throwError: ret fd].
  ret
].


addr@(SocketAddress traits) newOn: array port: port
[ | ret |
  ret: addr new.
  addr address: (addr domain createIPAddress: array port: port options: #()).
  addr
].

addr@(IP4Address traits) domain
[
  Socket Domains IP4
].

addr@(UnixDomainAddress traits) domain
[
  Socket Domains Local
].


s@(Socket traits) connectTo: addr@(SocketAddress traits)
[ | ret |
  ret: (s fd socketConnect: addr address).
  ret < 0 /\ [ret ~= Socket ErrorCodes InProgress] ifTrue: [s throwError: ret].
  
].


s@(Socket traits) bindTo: sa@(SocketAddress traits)
[ | ret |
  s fd < 0 ifTrue: [s throwError: Socket ErrorCodes Invalid].
  
  ret: (s fd socketBindOn: sa address).
  ret < 0 ifTrue: [s throwError: ret].
  ret
].

s@(Socket traits) listenSize: count
[ | ret |
  
  ret: (s fd socketListenSize: count).
  ret < 0 ifTrue: [s throwError: ret].
  ret
].


s@(Socket traits) close
[ | ret |
  ret: s fd closePipe.
  ret < 0 ifTrue: [s throwError: ret].
].


s@(Socket traits) acceptConnection
[ | ret |
  
  ret: (s fd socketAcceptConnection).
  (ret is: Integer) ifTrue: [s throwError: ret].
  (ret first < 0) ifTrue: [s throwError: ret first].
  SocketServerConnection new `>> [fd: ret first. peerAddress: ret second.]
].


s@(SocketServer traits) newOn: ip port: port dispatch: block
[ | ret |
  ret: s new `>> [ip: ip. port: port. dispatch: block.].
  ret
].

s@(SocketServer traits) start &domain: addressDomain
[
  addressDomain `defaultsTo: IP4Address.
  s pipeToLoop: 
    (currentProcess forkAndDo:
      [ | :commSock servSock |
        servSock: (Socket newFor: addressDomain domain type: Socket Types Stream protocol: Socket Protocols Default).
        "fixme handle ipv6"
        inform: 'Creating listening socket ' ; servSock printString.
        inform: 'bind: ' ; (servSock bindTo: (addressDomain newOn: s ip port: s port)) printString.
        inform: 'listen: '; (servSock listenSize: 5) printString.
        [ | ready |
          inform: 'Waiting for connection...' ; {commSock. servSock fd} printString.
          ready: ({commSock. servSock fd} selectOnReadPipesFor: Socket SelectTimeout).
          ready ifNil: [inform: 'Error waiting for pipes. Exiting...'. lobby exit].
          (ready includes: commSock) ifTrue: [inform: 'Got message from commsock. Exiting...'. commSock closePipe. servSock fd closePipe. lobby exit].
          (ready includes: servSock fd) 
            ifTrue: [ | peer child |
                       peer: ([servSock acceptConnection] on: Error do: [| :e | inform: 'Accept error: ' ; e description. e return: Nil]).
                       peer ifNotNil:
                         [child: (currentProcess 
                                   forkAndDo: [ |:parent| [s dispatch applyWith: parent with: peer]
                                                          ensure: [parent closePipe. peer fd closePipe. lobby exit]]).
                          "fixme... have a way to communinicated back"
                          peer fd closePipe.
                          child closePipe.
                          inform: 'Connection from ' ; peer peerAddress printString]]
        ] loop.
      ]).

].

s@(SocketServer traits) stop
[
  s pipeToLoop nextPutAll: 'quit'.
].


networking define: #SocketStream &parents: {ReadWriteStream}
 &slots: {#internalReadBuffer -> (ByteArray new as: Queue). #internalWriteBuffer -> (ByteArray new as: Queue). #socket -> Nil. #closed -> False.
#buffer -> (ByteArray new &capacity: Socket BufferSize)}.

s@(SocketStream traits) newOn: socket
[
  s new on: socket
].

s@(SocketStream traits) on: socket
[
  s socket: socket.
  s internalReadBuffer clear.
  s internalWriteBuffer clear.
  s closed: False.
  s
].

s@(SocketStream traits) collectionType
[
  ByteArray
].

s@(SocketStream traits) isAtEnd
[
  s closed
].


s@(SocketStream traits) close
[
  s closed: True.
  s socket close.
].


s@(SocketStream traits) flush
[ | i contents |
  i: 0.
  contents: (s internalWriteBuffer as: ByteArray).
  [i < contents size] whileTrue: 
    [ | return fds | 
      fds: ({s socket fd} selectOnWritePipesFor: Socket SelectTimeout).
      return: 0.
      inform: 'writing ' ; contents size printString ; ' bytes of ' ; contents printString.
      fds do: [ |:fd| return: (contents writeToPipe: fd start: i end: contents size)].
      (return = 0) ifTrue: [error: 'write failed']. 
      return < 0 /\ [return ~= Socket ErrorCodes InProgress] ifTrue: [s throwError: return].
      i: i + return].
  s internalWriteBuffer clear.
].

s@(SocketStream traits) next
[
  (s next: 1) first
].

s@(SocketStream traits) nextLine
[
  s upTo: $\n
].


s@(SocketStream traits) next: n putInto: seq startingAt: start
[ | readSize writer |
  s closed ifTrue: [s exhausted. ^ 0].
  writer: s internalReadBuffer writer.
  [s internalReadBuffer size < n]
    whileTrue: [ | fds ret |
                  fds: ({s socket fd} selectOnReadPipesFor: Socket SelectTimeout).
                  fds isEmpty ifTrue: [s closed: True. s exhausted. ^ 0]. "this shouldn't happen"
                  inform: 'before read ' ; fds printString.
                  ret: (s buffer readFromPipe: s socket fd start: 0 end: s buffer size).
                  inform: 'ret ' ; ret printString.
                  ret = 0 ifTrue: [s closed: True. s exhausted. ^ 0].
                  inform: 'read bytes: ' ; s buffer printString.
                  writer next: ret putAll: s buffer].
  readSize: (s internalReadBuffer size min: n).
  seq replaceFrom: start to: start - 1 + readSize with: s internalReadBuffer.
  s internalReadBuffer forgetFirst: readSize.
  readSize
].


s@(SocketStream traits) nextPut: byte
[ | ret |
  s internalWriteBuffer addLast: byte.
].

