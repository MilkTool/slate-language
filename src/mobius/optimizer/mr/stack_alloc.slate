Optimizer MR define: #RegisterStackAllocator &parents: {Cloneable} &slots:
{#architecture.
 #function.
 #registerFile.
 #instructions -> ExtensibleArray new.
 #killedRegisters -> IdentityDictionary new.
 #currentStack -> ExtensibleArray new.
 #stackIn -> IdentityDictionary new.
 #stackOut -> IdentityDictionary new}.

rsa@(Optimizer MR RegisterStackAllocator traits) newFunction: fun
[rsa cloneSettingSlots: #(function killedRegisters stackIn stackOut)
     to: {fun. rsa killedRegisters new. rsa stackIn new. rsa stackOut new}].

rsa@(Optimizer MR RegisterStackAllocator traits) kills: reg at: inst
[
  (rsa killedRegisters at: inst) includes: reg
].

rsa@(Optimizer MR RegisterStackAllocator traits) shuffleFrom: stackIn to: stackOut
[| permutation code | 
  permutation:
    (stackOut
      collectWithIndex:
        [| :reg :index |
          (stackIn at: index) == reg
            ifTrue:
             [index]
           ifFalse:
             [stackIn indexOf: reg]
        ]).
  code: {} writer.
  permutation
   doWithIndex:
     [| :dst :src |
       [dst = src]
         whileFalse:
           [src: dst.
             src = 0
               ifFalse:
                 [dst: (permutation at: src).
                   code nextPut: (rsa exchangeTopWith: src)].
             permutation at: src put: src]
     ].
  code contents
].

rsa@(Optimizer MR RegisterStackAllocator traits) exchangeTopWith: offset
[
  overrideThis
].

rsa@(Optimizer MR RegisterStackAllocator traits) popStack
[
  overrideThis
].

rsa@(Optimizer MR RegisterStackAllocator traits) storeTopInto: offset
[
  overrideThis
].

rsa@(Optimizer MR RegisterStackAllocator traits) deallocate: regs from: stack
[| code |
  code: {} writer.
  (regs collect: [| :reg | stack indexOf: reg]) sort
    doWithIndex:
      [| :dead :index |
        index = dead
          ifTrue:
            [stack removeFirst.
              code nextPut: rsa popStack]
          ifFalse:
            [stack at: dead - index - 1 put: stack removeFirst.
              code nextPut: (rsa storeTopInto: dead - index)]
      ].
  code contents
].

rsa@(Optimizer MR RegisterStackAllocator traits) findInstructionsIn: bb
[| live |
  live: IdentitySet new.
  bb liveOut
    do:
      [| :var reg |
        reg: var register.
        (reg is: Optimizer MR Register) /\
          [reg registerFile == rsa registerFile]
          ifTrue:
            [live include: reg]
      ].
  rsa instructions: rsa instructions new.
  bb instructions
    reverseDo:
      [| :inst usesRegisters |
        usesRegisters: False.
        inst
          outputsDo:
            [| :reg :mode |
              (reg is: Optimizer MR Register) /\
                [reg registerFile == rsa registerFile]
                ifTrue:
                  [usesRegisters: True.
                    live remove: reg]
            ].
        inst
          inputsDo:
            [| :reg :mode |
              (reg is: Optimizer MR Register) /\
                [reg registerFile == rsa registerFile]
                ifTrue:
                  [usesRegisters: True.
                    (live includes: reg)
                      ifFalse:
                        [(rsa killedRegisters
                           at: inst
                           ifAbsentPut: [IdentitySet new]) include: reg]]
            ].
        usesRegister
          ifTrue:
            [rsa instructions addFirst: inst]
      ]
].

rsa@(Optimizer MR RegisterStackAllocator traits) rewrite: inst
[
  overrideThis
].

rsa@(Optimizer MR RegisterStackAllocator traits) rewrite: inputs@(Optimizer MR CallInputs traits)
[
  rsa shuffleFrom: rsa currentStack
    to: (Stack newWithAll:
          (inputs operands select:
            [| :var |
              var registerFile == rsa registerFile]))
].

rsa@(Optimizer MR RegisterStackAllocator traits) rewrite: outputs@(Optimizer MR CallOutputs traits)
[
  rsa currentStack:
    (Stack newWithAll:
      (outputs operands select:
        [| :var |
          var registerFile == rsa registerFile])).
  {}
].

rsa@(Optimizer MR RegisterStackAllocator traits) assignStackLocationsTo: bb
[| dead |
  rsa findInstructionsIn: bb.
  rsa currentStack: (rsa currentStack newWithAll: (rsa stackIn at: bb)).
  dead: (rsa currentStack select: [| :reg | bb liveIn noneSatisfy: [| :var | var register == reg]]).
  dead isEmpty
    ifFalse:
      [bb addAllFirst: (rsa deallocate: dead from: rsa currentStack)].
  rsa instructions
    do:
      [| :inst |
        bb replace: inst withAll: (rsa rewrite: inst)
      ].
  rsa stackOut at: bb put: rsa currentStack.
  bb successors
    do:
      [| :succ |
        rsa stackIn
          at: succ
          ifAbsentPut: [rsa currentStack]
      ]
].

rsa@(Optimizer MR RegisterStackAllocator traits) assignStackLocations
[
  rsa stackIn at: rsa function basicBlocks first put: 
    (Stack newWithAll: 
      (rsa function inputVariables select: 
        [| :var | 
          rsa registerFile registers includes: var register])).
  rsa function basicBlocks
    do:
      [| :bb |
        rsa assignStackLocationsTo: bb
      ].
  rsa function basicBlocks last
    addAllLast:
      (rsa shuffleFrom: rsa currentStack
        to: (Stack newWithAll:
              (rsa function outputVariables select:
                [| :var |
                  rsa registerFile registers includes: var register])))
].


rsa@(Optimizer MR RegisterStackAllocator traits) splitEdgeFrom: src to: dst
[| edge |
  edge: Optimizer MR BasicBlock new.
  rsa function basicBlocks add: edge.
  src replaceLabel: dst with: edge.
  rsa jumpFrom: edge to: dst.
  edge
].

rsa@(Optimizer MR RegisterStackAllocator traits) jumpFrom: src to: dst
[
  overrideThis
].

rsa@(Optimizer MR RegisterStackAllocator traits) resolveConflictsAt: bb
[| stackOut |
  stackOut: (rsa stackOut at: bb).
  bb successors isEmpty
    ifTrue:
      [stackOut isEmpty
        ifFalse:
          [bb 
            addAllLast:
              (rsa deallocate: stackOut from: stackOut)].
        ^ Nil].
  bb successors first
    addAllLast:
      (rsa shuffleFrom: stackOut to: (rsa stackIn at: bb successors first)).
  stackOut: (rsa stackIn at: bb successors first).
  bb successors
    do:
      [| :succ stackIn |
        stackIn: (rsa stackIn at: succ).
        stackIn = stackOut
          ifFalse:
            [| newSucc newStack |
              newSucc: (rsa function splitEdgeFrom: bb to: succ).
              newStack: stackOut copy.
              newSucc
                addAllFirst:
                  (rsa 
                    deallocate: 
                      (stackOut reject: [| :reg | stackIn includes: reg]).
                    from: 
                      newStack).
              newSucc
                addAllLast:
                  (rsa shuffleFrom: newStack to: stackIn)
            ]
      ]
]. 

rsa@(Optimizer MR RegisterStackAllocator traits) resolveConflicts
[
  rsa function basicBlocks copy
    do:
      [| :bb |
        rsa resolveConflictsAt: bb
      ]
].

