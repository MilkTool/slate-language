Optimizer MR define: #Generator &parents: {Cloneable} &slots:
{#module -> Optimizer MR Module.
 #functions -> IdentityDictionary new.
 #function -> Optimizer MR Function.
 #variables -> IdentityDictionary new.
 #continuations -> IdentityDictionary new.
 #basicBlock}.

g@(Optimizer MR Generator traits) newArchitecture: module
[
  g cloneSettingSlots: #(module functions continuations)
    to: {g module newArchitecture: module. g functions new. g continuations new}
].

g@(Optimizer MR Generator traits) addVariable: v@(Optimizer IR GlobalVariable traits)
[
  g module globalVariables add:
    (Optimizer MR GlobalVariable newNamed: v name) `>>
      [type: v type.
        module: g module.
        value: v value. ]
].

g@(Optimizer MR Generator traits) addVariable: v@(Optimizer IR InputVariable traits)
[
  g variables at: v put:
    (Optimizer MR InputVariable newNamed: v name) `>>
      [type: v type. ]
].

g@(Optimizer MR Generator traits) addVariable: v@(Optimizer IR OutputVariable traits)
[
  g variables at: v put:
    (Optimizer MR OutputVariable newNamed: v name) `>>
      [type: v type. ]
].

g@(Optimizer MR Generator traits) addVariable: v@(Optimizer IR LocalVariable traits)
[
  g variables at: v put:
    (Optimizer MR LocalVariable newNamed: v name) `>>
      [type: v type. ]
].

g@(Optimizer MR Generator traits) addVariable: c@(Optimizer IR Constant traits)
[
  (Optimizer MR Constant newValue: c value) `>>
    [type: c type. ]
].

g@(Optimizer MR Generator traits) addTemporary: type
[
  g function localVariables addLast: (Optimizer MR LocalVariable new `>> [type: type. ])
].

g@(Optimizer MR Generator traits) generatePrologue
[
  overrideThis
].

g@(Optimizer MR Generator traits) generateEpilogue
[
  overrideThis
].

g@(Optimizer MR Generator traits) assignInputs: inputs ifSuccess: success ifFailure: failure
[| freeRegs |
  freeRegs: IdentityDictionary new.
  inputs do: [| :input rf regs |
    rf: (g module architecture registerFiles detect: [| :rf |
          (rf accepts: input) /\ [rf inputRegisters isNotEmpty]]).
    rf isNil \/
      [regs: (freeRegs at: rf ifAbsentPut: [rf inputRegisters reader]).
        regs isAtEnd]
      ifTrue:
        [failure applyWith: input]
      ifFalse:
        [success applyWith: input with: regs next]]
].

g@(Optimizer MR Generator traits) assignOutputs: outputs ifSuccess: success ifFailure: failure
[| freeRegs |
  freeRegs: IdentityDictionary new.
  outputs do: [| :output rf regs |
    rf: (g module architecture registerFiles detect: [| :rf |
          (rf accepts: output) /\ [rf outputRegisters isNotEmpty]]).
    rf isNil \/
      [regs: (freeRegs at: rf ifAbsentPut: [rf outputRegisters reader]).
        regs isAtEnd]
      ifTrue:
        [failure applyWith: output]
      ifFalse:
        [success applyWith: output with: regs next]]
].

g@(Optimizer MR Generator traits) generate: f@(Optimizer IR Function traits)
[
  g variables: g variables new.
  g continuations: g continuations new.
  g basicBlock: Nil.
  g function: (g functions at: f) `>>
       [module: g module.
         inputVariables:
           (f inputVariables
             collect: #addVariable: `er <- g
             into: g function inputVariables).
         outputVariables:
           (f outputVariables
             collect: #addVariable: `er <- g
             into: g function outputVariables).
         localVariables:
           (f localVariables
             collect: #addVariable: `er <- g
             into: g function localVariables).
         constants:
           (f constants
             collect: #addVariable: `er <- g
             into: g function constants).
       ].
  g module functions add: g function.
  g assignInputs: g function inputVariables
    ifSuccess: [| :input :reg | input register: reg]
    ifFailure: [| :_ |].
  g assignOutputs: g function outputVariables
    ifSuccess: [| :output :reg | output register: reg]
    ifFailure: [| :_ | error: 'A function output could not be assigned to a register.'].
  g generatePrologue.
  g generate: f child.
  g generateEpilogue.
  g function
].

g@(Optimizer MR Generator traits) ensureBasicBlock
[
  g basicBlock
    ifNil:
      [g basicBlock: (g function basicBlocks addLast: Optimizer MR BasicBlock new)]
].

g@(Optimizer MR Generator traits) jumpTo: dst
[
  overrideThis
].

g@(Optimizer MR Generator traits) generate: r@(Optimizer IR ReturnToContinuation traits)
[g returnTo: r continuation].

g@(Optimizer MR Generator traits) generate: c@(Optimizer IR Continuation traits)
"TODO: Handle non-local returns."
[| bb |
  "The continuation basic block."
  bb: Optimizer MR BasicBlock new.
  g continuations at: c put: bb.
  "Generate the body."
  g generate: c child.
  "Jump to the continuation basic block upon completion of the body."
  g ensureBasicBlock.
  g jumpTo: bb.
  g function basicBlocks addLast: bb.
  g basicBlock: bb
].

g@(Optimizer MR Generator traits) generate: l@(Optimizer IR Loop traits)
[| bb |
  "The loop head basic block."
  bb: Optimizer MR BasicBlock new.
  g function basicBlocks addLast: bb.
  "Generate the body starting at the loop head."
  g ensureBasicBlock.
  g jumpTo: bb.
  g basicBlock: bb.
  g generate: l child.
  "Jump back to the loop head."
  g ensureBasicBlock.
  g jumpTo: bb.
  g basicBlock: Nil
].

g@(Optimizer MR Generator traits) branchTo: dst if: x equals: y
[
  overrideThis
].

g@(Optimizer MR Generator traits) generate: m@(Optimizer IR Match traits)
"TODO: Optimize the case where successChild or failureChild is an empty sequence."
[| successBB failureBB continuationBB |
  g function basicBlocks addAllLast:
    {successBB: Optimizer MR BasicBlock new. "Successful match BB."
     failureBB: Optimizer MR BasicBlock new. "Failed match BB."
     continuationBB: Optimizer MR BasicBlock new "Continuation BB"}.
  "Generate the comparison."
  g ensureBasicBlock.
  g branchTo: successBB if: m value equals: m key.
  (g basicBlock instructions anySatisfy: #is: `er <-* Optimizer MR Jump)
    ifFalse:
      [g jumpTo: failureBB].
  "Generate the successful match body."
  g basicBlock: successBB.
  g generate: m successChild.
  "Return to the continuation upon completion of the successful match body."
  g ensureBasicBlock.
  g jumpTo: continuationBB.
  "Generate the failed match body."
  g basicBlock: failureBB.
  g generate: m failureChild.
  "Return to the continuation upon completion of the failued match body."
  g ensureBasicBlock.
  g jumpTo: continuationBB.
  g basicBlock: continuationBB
].

g@(Optimizer MR Generator traits) generate: s@(Optimizer IR Sequence traits)
[
  s children do: #generate: `er <- g
].

g@(Optimizer MR Generator traits) generate: i@(Optimizer IR Instruction traits)
[
  overrideThis
].

g@(Optimizer MR Generator traits) generate: b@(Optimizer IR BasicBlock traits)
[
  b instructions isEmpty
    ifFalse:
      [g ensureBasicBlock.
        b instructions do: #generate: `er <- g]
].

g@(Optimizer MR Generator traits) generate: m@(Optimizer IR Module traits)
[
  m globalVariables do: #generate: `er <- g.
  m functions do: [| :f | g functions at: f put: (g function newNamed: f name)].
  m functions do: #generate: `er <- g
].

g@(Optimizer MR Generator traits) generate: v@(Optimizer IR GlobalVariable traits)
[
  g module globalVariables
    detect: [| :m | m name = v name]
    ifNone: [error: 'Unknown global variable: ' ; v name printString]
].

g@(Optimizer MR Generator traits) generate: v@(Optimizer IR LocalVariable traits)
[
  g variables at: v
    ifAbsent: [error: 'Unknown local variable: ' ; v name printString]
].

g@(Optimizer MR Generator traits) generate: c@(Optimizer IR Constant traits)
[
  g function constants
    detect: [| :m | m value = c value /\ [m type = c type]]
    ifNone: [error: 'Unknown constant: ' ; c value printString]
].

g@(Optimizer MR Generator traits) generate: f@(Optimizer IR Label traits)
[
  Optimizer MR Label newTarget: (g functions at: f target)
].

g@(Optimizer MR Generator traits) move: src to: dst
[
  overrideThis
].

g@(Optimizer MR Generator traits) pushUnassignedInputs: inputs
[
  overrideThis
].

g@(Optimizer MR Generator traits) popUnassignedInputs: inputs
[
  overrideThis
].

g@(Optimizer MR Generator traits) call: label
[
  overrideThis
].

g@(Optimizer MR Generator traits) generate: i@(Optimizer IR Call traits)
[| unassigned inputs outputs |
  inputs: {} writer.
  unassigned: {} writer.
  g assignInputs: (i inputs sliceFrom: 1)
    ifSuccess:
      [| :input :reg tmp |
        tmp: (g addTemporary: reg type) `>> [register: reg. ].
        inputs nextPut: tmp.
        g move: input to: tmp]
    ifFailure:
      [| :input |
        unassigned nextPut: input].
  g pushUnassignedInputs: unassigned contents.
  inputs position > 0
    ifTrue:
      [g basicBlock addLast: (Optimizer MR CallInputs newOperands: inputs contents)].

  g call: (g generate: i inputs first).

  outputs: {} writer.
  g assignOutputs: i outputs
    ifSuccess:
      [| :output :reg tmp |
        tmp: (g addTemporary: reg type) `>> [register: reg. ].
        outputs nextPut: tmp.
        g move: output to: tmp]
    ifFailure:
      [| :_ |
        error: 'A call output could not be assigned to a register.'].
  g popUnassignedInputs: unassigned contents.
  outputs position > 0
    ifTrue:
      [g basicBlock addLast: (Optimizer MR CallOutputs newOperands: outputs contents)]
].

g@(Optimizer MR Generator traits) generateInteger: i@(Optimizer IR Instruction traits)
[
  overrideThis
].

g@(Optimizer MR Generator traits) generateFloat: i@(Optimizer IR Instruction traits)
[
  overrideThis
].

g@(Optimizer MR Generator traits) generate: i@(Optimizer IR Comparison traits)
[
  (i outputs first type is: Types _Float)
    ifTrue: [g generateFloat: i]
    ifFalse: [g generateInteger: i]
].

g@(Optimizer MR Generator traits) generate: i@(Optimizer IR Arithmetic traits)
[
  (i outputs first type is: Types _Float)
    ifTrue: [g generateFloat: i]
    ifFalse: [g generateInteger: i]
].

