Optimizer MR define: #RegisterFileState &parents: {Cloneable} &slots:
{#registerFile.
 #spillCount -> 0.
 #availableRegisters -> ExtensibleArray new.
 #scratchRegisters -> Nil}.

rfs@(Optimizer MR RegisterFileState traits) newRegisterFile: rf@(Optimizer MR RegisterFile traits)
[rfs clone `>>
  [registerFile: rf.
    availableRegisters: (rfs availableRegisters newWithAll: rf registers).]
].
  
Optimizer MR define: #RegisterAllocator &parents: {Cloneable} &slots:
{#architecture.
 #function.
 #registerFiles -> IdentityDictionary new.
 #liveVariables.
 #unspillableVariables -> IdentitySet new.
 #conflictedRegisters -> IdentityDictionary new.
 #variableLocations -> IdentityDictionary new}.

ra@(Optimizer MR RegisterAllocator traits) newFunction: fun@(Optimizer MR Function traits)
[ra cloneSettingSlots: #(architecture function registerFiles conflictedRegisters)
    to: {fun module architecture.
	 fun.
	 (fun module architecture registerFiles select: [| :rf | rf allocatable])
           project: [| :rf | Optimizer MR RegisterFileState newRegisterFile: rf]
           into: ra registerFiles new.
	 ra conflictedRegisters new}
].

ra@(Optimizer MR RegisterAllocator traits) spill: var from: reg
[overrideThis].

ra@(Optimizer MR RegisterAllocator traits) reload: var into: reg
[overrideThis].

ra@(Optimizer MR RegisterAllocator traits) saveRegistersAcross: call@(Optimizer MR Call traits)
[
  ra liveVariables
    do:
      [| :var reg |
        reg: var register.
        (reg is: Optimizer MR Register) /\ [reg callerSave]
          ifTrue:
            [call basicBlock addAll: (ra spill: var from: reg) before: call.
             call basicBlock addAll: (ra reload: var into: reg) after: call]
      ].
  ra variableLocations
    keysAndValuesDo:
      [| :var :scratch |
        scratch callerSave
          ifTrue:
            [call basicBlock addAll: (ra reload: var into: scratch) after: call.
              ra liveVariables include: var]
      ].
  ra variableLocations: (ra variableLocations mapSelect: [| :_ :scratch | scratch calleeSave])
].

ra@(Optimizer MR RegisterAllocator traits) rewrite: call@(Optimizer MR Call traits)
[
  ra saveRegistersAcross: call.
  resend
].

ra@(Optimizer MR RegisterAllocator traits) rewrite: inputs@(Optimizer MR CallInputs traits)
[
  inputs operands: 
    (inputs operands reject: [| :var | 
      ra liveVariables include: var register.
      var register registerFile isSameAs: Optimizer MR RegisterFile]). 
  inputs operands isEmpty
    ifTrue:
      [inputs basicBlock remove: inputs]
].

ra@(Optimizer MR RegisterAllocator traits) rewrite: outputs@(Optimizer MR CallOutputs traits)
[
  outputs operands: 
    (outputs operands reject: [| :var | 
      ra liveVariables remove: var register.
      var register registerFile isSameAs: Optimizer MR RegisterFile]). 
  outputs operands isEmpty
    ifTrue:
      [outputs basicBlock remove: outputs]
].

ra@(Optimizer MR RegisterAllocator traits) rewrite: pseudo@(Optimizer MR PseudoInstruction traits)
[
  resend.
  pseudo basicBlock remove: pseudo
].

ra@(Optimizer MR RegisterAllocator traits) spillScratchRegisterFrom: regs excluding: conflicts after: inst
[| spill reg |
  spill:
    ((regs
       collect:
         [| :spill | ra variableLocations keyAtValue: spill])
      detect:
        [| :spill | (conflicts includes: spill) not]).
  reg: (ra variableLocations removeKey: spill).
  inst basicBlock addAll: (ra reload: spill into: reg) after: inst.
  ra liveVariables include: spill.
  reg
].

ra@(Optimizer MR RegisterAllocator traits) rewriteOutputs: inst
[| outputs |
  outputs: IdentitySet new.
  inst
    transformOutputs:
      [| :operand :mode |
        (operand is: Optimizer MR LocalVariable)
          ifTrue:
            [| reg |
              reg: operand register.
              (reg is: Optimizer MR Register)
                ifTrue:
                  [mode isInput
                    ifFalse: 
                      [ra liveVariables remove: operand]]
                ifFalse:
                  [reg:
                    (ra variableLocations
                      at: operand
                      ifAbsent:
                        [operand usesMemory /\
                          [(inst operands count: [| :mem | mem is: Optimizer MR Memory]) < inst memoryUseLimit]
                          ifTrue:
                            [mode isInput
                              ifTrue:
                                [ra liveVariables include: operand].
                              operand spillLocation]
                          ifFalse:
                            [ra variableLocations
                              at: operand
                              put:
                                (reg 
                                  detect:
                                    [| :scratch | (ra variableLocations includes: scratch) not]
                                  ifNone:
                                    [ra 
                                      spillScratchRegisterFrom: reg 
                                      excluding: outputs 
                                      after: inst])]]).
                    (ra liveVariables includes: operand)
                      ifTrue:
                        [ra variableLocations
                          at: operand
                          ifPresent:
                            [| :scratch |
                              inst basicBlock addAll: (ra spill: operand from: scratch) after: inst]].
                    outputs include: operand.
                    mode isInput
                      ifFalse:
                        [ra unspillableVariables include: operand.
                          ra variableLocations removeKey: operand]].
              reg
            ]
          ifFalse:
            [operand]
      ]
].

ra@(Optimizer MR RegisterAllocator traits) rewriteInputs: inst
[
  inst
    transformInputs:
      [| :operand :mode |
        (operand is: Optimizer MR LocalVariable)
          ifTrue:
            [| reg |
              reg: operand register.
              (reg is: Optimizer MR Register)
                ifTrue:
                  [ra liveVariables include: operand]
                ifFalse:
                  [reg:
                    (variableLocations
                      at: operand
                      ifAbsent:
                        [reg:
                          (reg 
                            detect: 
                              [| :scratch | (ra variableLocations includes: scratch) not]
                            ifNone:
                              [mode usesMemory /\
                                [(inst operands count: [| :mem | mem is: Optimizer MR Memory]) < inst memoryUseLimit]
                                ifTrue:
                                  [ra liveVariables include: operand.
                                    operand spillLocation]
                                ifFalse:
                                   [ra 
                                     spillScratchRegisterFrom: reg 
                                     excluding: ra unspillableVariables 
                                     after: inst]]).
                          reg == operand spillLocation
                            ifFalse:
                              [ra variableLocations at: operand put: reg].
                          reg]).
                    ra unspillableVariables include: operand].
              reg 
            ]
          ifFalse:
            [operand]
      ]
].

ra@(Optimizer MR RegisterAllocator traits) rewrite: inst
[
  ra unspillableVariables: ra unspillableVariables new.
  ra rewriteOutputs: inst.
  ra rewriteInputs: inst
].

ra@(Optimizer MR RegisterAllocator traits) rewrite: inst@(Optimizer MR Move traits)
[
  resend.
  inst operands first == inst operands second
    ifTrue: 
      [inst basicBlock remove: inst]
].

ra@(Optimizer MR RegisterAllocator traits) rewriteInstructions
[
  ra function basicBlocks
    do:
      [| :bb |
        ra variableLocations: ra variableLocations new.
        ra liveVariables: (bb liveOut as: IdentitySet).
        bb instructions
          reverseDo:
            [| :inst |
              ra rewrite: inst
            ].
        ra variableLocations
          keysAndValuesDo:
            [| :var :scratch |
              bb addAllFirst: (ra reload: var into: scratch)
            ]
      ]
].         
            
ra@(Optimizer MR RegisterAllocator traits) findConflicts
[| conflicts liveVariables |
  conflicts: {}.
  liveVariables: 
    (SortedArray 
      newSortedBy:
        [| :x :y |
          x intervalEnd < y intervalEnd
        ]).
  ra function localVariables
    do:
      [| :var |
        [liveVariables isNotEmpty /\
          [liveVariables first intervalEnd < var intervalStart]]
          whileTrue:
            [| expired |
              expired: liveVariables removeFirst.
              expired register
                ifNotNilDo:
                  [| :reg |
                    conflicts: (conflicts copyWithoutAt: (conflicts indexOf: reg))
                  ]
            ].
        var register
          ifNotNilDo:
            [| :reg |
              conflicts: (conflicts copyWith: reg).
              liveVariables do:
                [| :conflict |
                  (conflict conflicts includes: reg)
                    ifFalse:
                      [conflict conflicts: (conflict conflicts copyWith: reg)]
                ]                  
            ].
        liveVariables add: var.
        var conflicts: conflicts
      ]
].

ra@(Optimizer MR RegisterAllocator traits) removeConflictsWith: var
[
  var conflicts do:
    [| :conflict |
      ra conflictedRegisters
        at: conflict
        ifPresent:
          [| :count |
            count = 1
              ifTrue:
                [(ra registerFiles at: conflict registerFile) availableRegisters addLast: conflict.
                   ra conflictedRegisters removeKey: conflict]
              ifFalse:
                [ra conflictedRegisters at: conflict put: count - 1]
          ]
    ]
].

ra@(Optimizer MR RegisterAllocator traits) retireVariable: expired
[
  expired register
    ifNil:
      [| rfs |
        rfs: (ra registerFiles atSatisfying: [| :rf | rf accepts: expired]).
        expired register: rfs scratchRegisters.
        rfs spillCount: rfs spillCount - 1.
        rfs spillCount = 0
          ifTrue:
            [rfs availableRegisters addAll: rfs scratchRegisters.
              rfs scratchRegisters: Nil]
      ]
    ifNotNilDo:
      [| :reg |.
        ra conflictedRegisters
          at: reg
          ifAbsent:
            [(ra registerFiles at: reg registerFile) availableRegisters addLast: reg]
      ].
  ra removeConflictsWith: expired
].

ra@(Optimizer MR RegisterAllocator traits) establishConflictsWith: var
[
  var conflicts do:
    [| :conflict |
      ra conflictedRegisters
        at: conflict
        put:
          (ra conflictedRegisters
            at: conflict
            ifAbsent:
              [(ra registerFiles at: conflict registerFile) availableRegisters remove: conflict.
                0]) + 1
    ]
].

ra@(Optimizer MR RegisterAllocator traits) assignScratchRegistersFor: rfs
[
  rfs scratchRegisters: (Array newSize: rfs registerFile scratchRegisters).
  rfs scratchRegisters
    keysDo:
      [| :index spill |
        spill:
          (ra liveVariables
            lastSatisfying:
              [| :spill |
                spill register isNotNil /\
                  [spill register registerFile == rf] /\
                  [(ra unspillableVariables includes: spill) not]]).
        rfs scratchRegisters at: index put: spill register.
        spill register: Nil.
      ].
  rfs spillCount: rfs scratchRegisters size
].

ra@(Optimizer MR RegisterAllocator traits) assignRegisters
[
  ra liveVariables: 
    (SortedArray 
      newSortedBy:
        [| :x :y |
          x intervalEnd < y intervalEnd
        ]).
  ra function localVariables
    do:
      [| :var rfs |
        [ra liveVariables isNotEmpty /\
          [ra liveVariables first intervalEnd < var intervalStart]]
          whileTrue:
            [ra retireVariable: ra liveVariables removeFirst].
        ra establishConflictsWith: var.
        ra liveVariables add: var.
        rfs: (ra registerFiles atSatisfying: [| :rf | rf accepts: var]).
        rfs ifNil: [error: 'Could not find applicable register file for variable.'].
        var register
          ifNil:
            [rfs availableRegisters isEmpty
              ifTrue:
                [rfs scratchRegisters
                  ifNil:
                    [ra assignScratchRegistersFor: rfs].
                  rfs spillCount: rfs spillCount + 1]
              ifFalse:
                [var register: rfs availableRegisters removeFirst]]
          ifNotNilDo:
            [| :reg |
              ra unspillableVariables include: var.
              rfs availableRegisters remove: reg
            ]
      ].
  [ra liveVariables isEmpty]
    whileFalse:
      [ra retireVariable: ra liveVariables removeFirst]
].
                    
ra@(Optimizer MR RegisterAllocator traits) allocateRegisters
[
  ra function computeDepthFirstOrder.
  ra function computeLiveness.
  ra findConflicts.
  ra assignRegisters.
  ra rewriteInstructions.
  ra function
].

       
