cf@(Optimizer IR ControlFlow traits) walkDominatorsBeforeDescent: before afterAscent: after
[
  cf walkDominators: Stack new beforeDescent: before afterAfter: after
].

cf@(Optimizer IR ControlFlow traits) walkDominatorsBeforeDescent: before
[
  cf walkDominators: Stack new beforeDescent: before afterAfter: [| :x :y |]
].

cf@(Optimizer IR ControlFlow traits) walkDominatorsAfterAscent: after
[
  cf walkDominators: Stack new beforeDescent: [| :x :y |] afterAfter: after
].

cf@(Optimizer IR ControlFlow traits) walkDominators: before
[
  cf walkDominators: Stack new beforeDescent: before afterAfter: [| :x :y |]
].

_@(Optimizer IR ControlFlow traits) walkDominators: _ beforeDescent: _ afterAscent: _
[
  Nil
].

fun@(Optimizer IR Function traits) walkDominators: dominators beforeDescent: before afterAscent: after
[
  fun child walkDominators: dominators beforeDescent: before afterAscent: after.
  [dominators isEmpty]
    whileFalse:
      [after applyWith: dominators with: dominators pop]
].

cl@(Optimizer IR Closure traits) walkDominators: dominators beforeDescent: before afterAscent: after
[
  cl child walkDominators: dominators beforeDescent: before afterAscent: after.
  [dominators isEmpty]
    whileFalse:
      [after applyWith: dominators with: dominators pop]
].

loop@(Optimizer IR Loop traits) walkDominators: dominators beforeDescent: before afterAscent: after
[
  loop child walkDominators: dominators beforeDescent: before afterAscent: after
].

label@(Optimizer IR Label traits) walkDominators: dominators beforeDescent: before afterAscent: after
[| depth |
  depth: dominators size.
  label child walkDominators: dominators beforeDescent: before afterAscent: after.
  [dominators size > depth]
    whileTrue:
      [after applyWith: dominators with: dominators pop]
].

bb@(Optimizer IR BasicBlock traits) walkDominators: dominators beforeDescent: before afterAscent: after
[
  before applyWith: dominators with: bb
].

match@(Optimizer IR Match traits) walkDominators: dominators beforeDescent: before afterAscent: after
"TODO: Ideally this could check if there was a return to a label within either the success or failure
child and determine that the remaining branch was a valid dominator up until the label. For now, however,
this is a 'good enough' conservative approximation of dominance."
[| depth |
  before applyWith: dominators with: match.
  dominators push: match.
  depth: dominators size.
  match successChild 
    walkDominators: dominators 
    beforeDescent: before 
    afterAscent: after.
  [dominators size > depth]
    whileTrue:
      [after applyWith: dominators with: dominators pop].
  match failureChild
    walkDominators: dominators
    beforeAscent: before
    afterAscent: after.
  [dominators size > depth]
    whileTrue:
      [after applyWith: dominators with: dominators pop]
].

seq@(Optimizer IR Sequence traits) walkDominators: dominators beforeDescent: before afterAscent: after
[
  seq children
    do:
      [| :child |
        child walkDominators: dominators beforeDescent: before afterAscent: after
      ]
].

