Optimizer IR define: #Generator &parents: {Cloneable} &slots:
{#module -> Optimizer IR Module.
 #modes -> IdentityDictionary new.
 #variables -> IdentityDictionary new.
 #labels -> IdentityDictionary new.
 #results -> Stack new.
 #controlFlow -> Stack new.
 #contexts -> Stack new}.

Optimizer IR Generator traits define: #Context &parents: {Cloneable} &slots:
{#mode -> Syntax Mode Slate.
 #method.
 #inputVariables.
 #scope.
 #basicBlock.
 #propagateConstants -> True}.

Optimizer IR Generator addSlotsFrom: Optimizer IR Generator Context.

gen@(Optimizer IR Generator traits) new
[
  gen cloneSettingSlots: #(module modes variables labels results controlFlow contexts)
      to:
	{gen module new.
	 gen modes new.
	 gen variables new.
	 gen labels new.
	 gen results new.
	 gen controlFlow new.
	 gen contexts new}
].

gen@(Optimizer IR Generator traits) pushContext
"Pushes the Generator's current context state as a separate Context object
onto the Generator's stack."
[
  gen contexts push:
    (gen Context cloneSettingSlots:
      #(mode method inputVariables scope basicBlock propagateConstants)
      to: {gen mode.
	   gen method.
           gen inputVariables.
           gen scope.
           gen basicBlock.
           gen propagateConstants}).
  gen
].

gen@(Optimizer IR Generator traits) popContext
"Set the Generator's context state from the top (popped) context object from
the Generator's stack."
[| context |
  context: gen contexts pop.
  gen mode: context mode.
  gen method: context method.
  gen inputVariables: context inputVariables.
  gen scope: context scope.
  gen basicBlock: context basicBlock.
  gen propagateConstants: context propagateConstants.
  gen
].

gen@(Optimizer IR Generator traits) emit: instruction@(Optimizer IR Instruction traits)
"Emits an instruction, generating a basicBlock as necessary. However, this
method requires the control flow stack to be set up correctly before
being called."
[| basicBlock |
  basicBlock: gen basicBlock.
  "TODO: Refactor this initialization to a non-emit: selector?"
  basicBlock ifNil:
    [basicBlock: Optimizer IR BasicBlock new.
     gen emit: basicBlock].
  basicBlock addLast: instruction
].

gen@(Optimizer IR Generator traits) emit: insts@(Collection traits)
[
  insts do: [| :inst | gen emit: inst]
].

gen@(Optimizer IR Generator traits) emit: cf@(Optimizer IR ControlFlow traits)
[
  gen basicBlock: Nil.
  gen controlFlow top addChild: cf
].

gen@(Optimizer IR Generator traits) emit: bblock@(Optimizer IR BasicBlock traits)
[
  gen basicBlock: bblock.
  gen controlFlow top addChild: bblock
].

gen@(Optimizer IR Generator traits) makeInputVariable: type
[
  gen scope ifNotNilDo:
    [| :scope |
     scope inputVariables addLast:
       (Optimizer IR InputVariable cloneSettingSlots: #(type scope) to: {type. gen scope})].
].

gen@(Optimizer IR Generator traits) makeOutputVariable: type
[
  gen scope ifNotNilDo:
    [| :scope | scope outputVariables addLast:
      (Optimizer IR OutputVariable cloneSettingSlots: #(type scope) to: {type. gen scope})]
].

gen@(Optimizer IR Generator traits) makeLocalVariable: varNode
[| var |
  var: (Optimizer IR LocalVariable cloneSettingSlots: #(type scope name)
    to: {varNode type. gen scope. varNode name}).
  gen scope ifNotNilDo: [| :scope | scope localVariables add: var].
  gen modes at: var put: gen mode.
  gen variables at: varNode put: var
].

gen@(Optimizer IR Generator traits) addLocalVariables: blockNode
[
  blockNode localVariables do: [| :varNode | gen makeLocalVariable: varNode]
].

gen@(Optimizer IR Generator traits) addInputVariables: blockNode
[| set |
  blockNode inputVariables collect:
    [| :varNode |
     gen emit: (Optimizer IR SetVariable
	   newFrom: {gen makeInputVariable: varNode type}
	   to: {gen makeLocalVariable: varNode})]
].

gen@(Optimizer IR Generator traits) makeTemporaryVariable: type
[
  gen scope ifNotNilDo:
    [| :scope |
     scope localVariables add:
       (Optimizer IR LocalVariable cloneSettingSlots: #(type scope) to: {type. gen scope})]
].

gen@(Optimizer IR Generator traits) makeConstant: type valued: value
[
  gen scope ifNotNilDo:
    [| :scope |
     scope constants add:
       (Optimizer IR Constant cloneSettingSlots: #(type value)
			      to: {gen mode = #Primitive /\ [type = Types Any]
			             ifTrue: [value primitiveType]
				     ifFalse: [type].
	value})]
].

gen@(Optimizer IR Generator traits) generateArgument: argument
[
  gen results push: (gen makeTemporaryVariable: argument type).
  gen propagateConstants
    ifTrue: [gen generate: argument]
    ifFalse:
      [gen pushContext.
       gen propagateConstants: True.
       gen generate: argument.
       gen popContext].
  gen results pop
].

gen@(Optimizer IR Generator traits) generateResult: result
[
  gen propagateConstants
    ifTrue:
      [gen pushContext.
       gen propagateConstants: False.
       gen generate: result.
       gen popContext.
       gen results top]
    ifFalse:
      [gen generate: result]
].

gen@(Optimizer IR Generator traits) generateResult: result into: var
[
  gen results push: var.
  gen propagateConstants
    ifTrue:
      [gen pushContext.
       gen propagateConstants: False.
       gen generate: result.
       gen popContext]
    ifFalse: [gen generate: result].
  gen results pop
].

gen@(Optimizer IR Generator traits) generate: blockNode@(Syntax Block traits)
[| closure label inst |
  gen mode = #Primitive
    ifTrue: [error: 'Primitive mode does not support block syntax.'].
  closure: (Optimizer IR Closure cloneSettingSlots: #(parent) to: {gen scope}).
  gen module closures add: closure.
  gen scope ifNotNilDo: [| :scope | scope closures add: closure].
  gen pushContext.
  gen scope: closure.
  label: Optimizer IR Continuation new.
  closure makeChild: label.
  gen controlFlow push: label.
  gen basicBlock: Nil.
  gen addLocalVariables: blockNode.
  gen addInputVariables: blockNode.
  blockNode statements allButLastDo:
    [| :statement | gen generateArgument: statement].
  "gen makeOutputVariable:
    (blockNode type ifNotNilDo: [| :type | type resultType])."
  gen makeOutputVariable: (blockNode type). "FIX?"


  blockNode statements isEmpty
    ifFalse: [gen generateResult: blockNode statements last
		  into: closure outputVariables first].
  gen controlFlow pop.
  gen popContext.
  gen scope ifNotNil:
    [gen emit: (Optimizer IR InstantiateClosure
	 newFrom: {Optimizer IR Label cloneSettingSlots: #(target) to: {closure}}
         to: {gen results top})].
  closure
].

gen@(Optimizer IR Generator traits) generate: methNode@(Syntax MethodDefinition traits)
[| meth label |
  gen mode = #Primitive
    ifTrue: [error: 'Primitive mode does not support method definition syntax.'].
  meth: (Optimizer IR Method newNamed: methNode selector) `>> [parent: gen scope.].
  gen module closures add: meth.
  gen scope ifNotNilDo: [| :scope | scope closures add: meth].
  gen pushContext.
  gen method: meth.
  gen scope: meth.
  label: Optimizer IR Continuation new.
  meth makeChild: label.
  gen controlFlow push: label.
  gen basicBlock: Nil.
  gen addLocalVariables: methNode.
  gen inputVariables: (gen addInputVariables: methNode).
  methNode statements allButLastDo:
    [| :statement | gen generateArgument: statement].
  "gen makeOutputVariable: (methNode type ifNotNilDo: #resultType `er )."
  gen makeOutputVariable: methNode type. "FIX?"
  methNode statements isEmpty ifFalse:
    [gen generateResult: methNode statements last into: meth outputVariables first].
  gen results pop.
  gen controlFlow pop.
  gen popContext.
  gen emit:
    {Optimizer IR InstantiateClosure newFrom:
      {Optimizer IR Label cloneSettingSlots: #(target) to: {meth}} to: {gen results top}.
     Optimizer IR DefineMethod newFrom:
       {gen results top} ; (methNode roles collect: [| :role | gen generateArgument: role])
         to: {gen results top}}.
  meth
].

gen@(Optimizer IR Generator traits) generate: _@(Syntax Resend traits)
[
  gen mode = #Primitive
    ifTrue: [error: 'Primitive mode does not support resend syntax.'].
  gen emit: (Optimizer IR ResendMethod newFrom:
    {gen makeConstant: Types Any valued: gen method selector} ; gen inputVariables
      to: {gen results top})
].

gen@(Optimizer IR Generator traits) generate: retNode@(Syntax ReturnClose traits)
[
  gen mode = #Primitive
    ifTrue: [error: 'Primitive mode does not support return syntax.'].
  gen method ifNil: [error: 'Return with no enclosing method.'].
  gen generateResult: retNode value into: gen method outputVariables first.
  gen emit: (Optimizer IR ReturnToContinuation newTo: gen method child)
].

gen@(Optimizer IR Generator traits) generate: retNode@(Syntax ReturnFar traits)
[| meth |
  gen mode = #Primitive
    ifTrue: [error: 'Primitive mode does not support return syntax.'].
  meth:
    (gen contexts detect: [| :context | context method isNotNil]
      ifNone: [error: 'Return with no enclosing method.']).
  gen generateResult: retNode value into: meth outputVariables first.
  gen emit: (Optimizer IR ReturnToContinuation newTo: meth child)
].

gen@(Optimizer IR Generator traits) generate: literalNode@(Syntax Literal traits)
[| constant |
  constant:
    (gen
      makeConstant:
        (gen mode = #Primitive /\ [literalNode type == Types Any]
          ifTrue: [literalNode value primitiveType]
          ifFalse: [literalNode type])
      valued: literalNode value).
  gen propagateConstants
    ifTrue:
      [gen results fromTop: 0 put: constant]
    ifFalse:
      [gen emit: (Optimizer IR Set newFrom: {constant} to: {gen results top})]
].

gen@(Optimizer IR Generator traits) generate: parenNode@(Syntax Parenthesis traits)
"Handles a compound statement sequence, with the expressions as inputs."
[
  parenNode statements allButLastDo: #generateArgument: `er <- gen.
  parenNode statements isEmpty ifFalse:
    [gen generate: parenNode statements last]
].

gen@(Optimizer IR Generator traits) generate: _@(Syntax ImplicitArgument traits)
"Handles an implicit context send with a CurrentNamespace instruction."
[
  gen mode = #Primitive
    ifTrue: [error: 'Primitive mode does not support implicit argument syntax.'].
  gen emit: (Optimizer IR CurrentNamespace newFrom: {} to: {gen results top})
].

gen@(Optimizer IR Generator traits) generate: loadNode@(Syntax LoadVariable traits)
"Generates a LoadFreeVariable."
[| var |
  var: (gen variables at: loadNode variable).
  var scope == gen scope
    ifFalse:
      [var nonLocalUses: var nonLocalUses + 1].
  gen mode = #Primitive /\
    [(gen modes
      at: var
      ifAbsent: [#Primitive]) = #Primitive]
    ifTrue:
      [gen propagateConstants
        ifTrue:
          [gen results fromTop: 0 put: var]
        ifFalse:
          [gen emit: (Optimizer IR SetVariable newFrom: {var} to: {gen results top})]]
    ifFalse:
      [gen emit: (Optimizer IR LoadFreeVariable newFrom: {var} to: {gen results top})]
].

gen@(Optimizer IR Generator traits) generate: storeNode@(Syntax StoreVariable traits)
"Generates a StoreFreeVariable followed by a SetVariable."
[| var val set |
  var: (gen variables at: storeNode variable).
  var scope == gen scope
    ifFalse:
      [var nonLocalUses: var nonLocalUses + 1].
  val: (gen generateArgument: storeNode value).
  gen emit: (gen mode = #Primitive /\
    [(gen modes
      at: var
      ifAbsent: [#Primitive]) = #Primitive]
      ifTrue: [Optimizer IR SetVariable newFrom: {val} to: {var}]
      ifFalse: [Optimizer IR StoreFreeVariable newFrom: {val} to: {var}]).
  gen propagateConstants
    ifTrue:
      [gen results fromTop: 0 put: val]
    ifFalse:
      [gen emit: (Optimizer IR SetVariable newFrom: {val} to: {gen results top})]
].

gen@(Optimizer IR Generator traits) generate: arrNode@(Syntax Array traits)
"Handle a literal array, with the statements as inputs."
[
  gen mode = #Primitive
    ifTrue: [error: 'Primitive mode does not support array syntax.'].
  gen emit: (Optimizer IR CreateArray
     newFrom: (arrNode statements collect: #generateArgument: `er <- gen)
     to: {gen results top})
].

gen@(Optimizer IR Generator traits) generate: msgNode@(Syntax Message traits)
"Force a primitive call for primitiveMode, or create a node for the send.
The selector is the first input, a constant."
[
  gen mode = #Primitive
    ifTrue: [^ (gen generatePrimitive: msgNode selector for: msgNode arguments)].
  gen emit: (Optimizer IR InvokeMethod
    newFrom: {gen makeConstant: Types Any valued: msgNode selector} ;
"        (msgNode arguments collect: gen #generateArgument: `er <- gen)"
        (msgNode arguments collect: #generateArgument: `er <- gen)
    to: {gen results top})
].

gen@(Optimizer IR Generator traits) generate: modeNode@(Syntax Mode traits)
"Set the mode in a new context and recurse into the modeNode's wrapper."
[
  gen pushContext.
  gen mode: modeNode mode.
  gen generate: modeNode value.
  gen popContext
].
