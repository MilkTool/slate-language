includeHeaderNamed: '<math.h>'.
includeHeaderNamed: '"slate.h"'.

obj@SmallIntegerTraits identityHash
"This overrides identityHash for SmallIntegers since they have no headers;
their hash is their direct value."
[
  interpreter stackPush:
    (obj isSmallInt
      ifTrue: [obj]
      ifFalse: [obj pointer header idHash asObject])
] `pidginPrimitive.

x@SmallIntegerTraits = y@SmallIntegerTraits
"Direct integer equality through low-level data comparison."
[
  interpreter stackPush:
    (x = y
      ifTrue: [CurrentMemory TrueObject]
      ifFalse: [CurrentMemory FalseObject])
] `pidginPrimitive.

x@SmallIntegerTraits < y@SmallIntegerTraits
[
  interpreter stackPush:
    (x asSmallInt < y asSmallInt
      ifTrue: [CurrentMemory TrueObject]
      ifFalse: [CurrentMemory FalseObject])
] `pidginPrimitive.

x@SmallIntegerTraits bitOr: y@SmallIntegerTraits
[
  interpreter stackPush: (x bitOr: y)
] `pidginPrimitive.

x@SmallIntegerTraits bitAnd: y@SmallIntegerTraits
[
  interpreter stackPush: (x bitAnd: y)
] `pidginPrimitive.

x@SmallIntegerTraits bitXor: y@SmallIntegerTraits
[
  interpreter stackPush: ((x bitXor: y) bitOr: SmallIntTag)
] `pidginPrimitive.

x@SmallIntegerTraits bitNot
[
  interpreter stackPush: (x bitNot bitOr: SmallIntTag)
] `pidginPrimitive.

x@SmallIntegerTraits bitShift: y@SmallIntegerTraits
[| z!LongInt bits!LongInt shift!LongInt |
  bits: x asSmallInt.
  shift: y asSmallInt.
  shift >= 0
    ifTrue:
      [shift >= 32 /\ [bits ~= 0]
        ifTrue: [^ (interpreter signal: BitShiftOverflowSymbol with: x with: y)].
        z: bits << shift.
        (z >> shift) = bits /\ [z fitsSmallInt]
          ifFalse:
            [^ (interpreter signal: BitShiftOverflowSymbol with: x with: y)]]
    ifFalse:
      [shift <= -32
        ifTrue: [z: bits >> 31]
        ifFalse: [z: bits >> shift negated]].
  interpreter stackPush: z asObject
] `pidginPrimitive.

x@SmallIntegerTraits + y@SmallIntegerTraits
[| z!LongInt |
  z: x asSmallInt + y asSmallInt.
  z fitsSmallInt
    ifTrue:
      [interpreter stackPush: z asObject]
    ifFalse:
      [interpreter signal: AddOverflowSymbol with: x with: y]
] `pidginPrimitive.

x@SmallIntegerTraits - y@SmallIntegerTraits
[| z!LongInt |
  z: x asSmallInt - y asSmallInt.
  z fitsSmallInt
    ifTrue:
      [interpreter stackPush: z asObject]
    ifFalse:
      [interpreter signal: SubtractOverflowSymbol with: x with: y]
] `pidginPrimitive.

x@SmallIntegerTraits * y@SmallIntegerTraits
[| z!LongInt |
  z: x asSmallInt!LongInt cast * y asSmallInt!LongInt cast.
  z > 16r3F_FF_FF_FF \/ [z < -16r40_00_00_00]
    ifTrue:
      [interpreter signal: MultiplyOverflowSymbol with: x with: y]
    ifFalse:
      [interpreter stackPush: z!LongInt cast asObject]
] `pidginPrimitive.

x@SmallIntegerTraits quo: y@SmallIntegerTraits
[
  y = SmallIntTag
    ifTrue:
      [interpreter signal: DivideByZeroSymbol with: x]
    ifFalse:
      [interpreter stackPush: (x asSmallInt / y asSmallInt) asObject]
] `pidginPrimitive.
