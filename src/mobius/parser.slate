Syntax define: #Parser &parents: {ReadStream} &slots:
  {#lexer -> Syntax Lexer.
   #lookAheadBuffer -> ExtensibleArray new.
   "A backing buffer of tokens for undo functionality."
   #currentScope -> Syntax Lobby.
   "Where expressions are evaluated."
   #typesNamespace -> Types.
   "Where expressions following ! annotations are evaluated."
   #parseInteractively -> False.
   "Whether a newline after a complete expression denotes completion."
   #parseConcatenatively -> False
   "Whether successive expressions are legal."}.
"Reads tokens from a Lexer and builds a Syntax Node tree for it."

node readFrom: p@(Syntax Parser traits)
[
  node lineNumber: p lexer lineNumber.
  node
].

node@(Syntax Node traits) readFrom: p@(Syntax Parser traits)
[
  resend `>> [source: p lexer source. ]
].

p@(Syntax Parser traits) on: source
"Target the parser to the particular source."
[
  p lexer: (p lexer newOn: source reader).
  p reset.
  p
].

p@(Syntax Parser traits) reset
[
  p lookAheadBuffer: p lookAheadBuffer new.
  p lexer reset.
].

p@(Syntax Parser traits) bufferToken: token
[p lookAheadBuffer addLast: token].

_@(Syntax Parser traits) bufferToken: token@(Syntax Token EndStream traits)
[token].

p@(Syntax Parser traits) bufferToken
"Places a new token at the end of the look-ahead buffer."
[p bufferToken: p lexer next].

p@(Syntax Parser traits) nextToken &interactive: interactive
"Takes the next token from either the buffer or the lexer transparently."
[| exclude token |
  interactive `defaultsTo: False.
  exclude: (interactive
    ifTrue: [{p surroundings Token Comment}]
    ifFalse: [{p surroundings Token Comment. p surroundings Token EndLine}]).
  [token: (p lookAheadBuffer isEmpty
     ifTrue: [p lexer next] ifFalse: [p lookAheadBuffer removeFirst]).
   exclude anySatisfy: [| :excluded | token isSameAs: excluded]] whileTrue.
  token
].

p@(Syntax Parser traits) peekToken &interactive: interactive
"Return the next token that the lexer has returned, but leave it in the buffer
and don't update the position."
[| exclude token |
  interactive `defaultsTo: False.
  exclude: (interactive
    ifTrue: [{p surroundings Token Comment}]
    ifFalse: [{p surroundings Token Comment. p surroundings Token EndLine}]).
  p lookAheadBuffer do:
    [| :token |
     (exclude noneSatisfy: [| :excluded | token isSameAs: excluded])
       ifTrue: [^ token]].
  [token: p bufferToken.
   exclude anySatisfy: [| :excluded | token isSameAs: excluded]] whileTrue.
  token
].

p@(Syntax Parser traits) isAtEnd
[
  p lookAheadBuffer isEmpty /\ [p lexer isAtEnd]
].

p@(Syntax Parser traits) undoToken: token
"Place the token back onto the stream buffer."
[
  p lookAheadBuffer addFirst: token
].

_@(Syntax Parser traits) undoToken: t@(Syntax Token EndStream traits)
"Avoid placing EndStream tokens in the look-ahead buffer."
[t].

Syntax Parser traits define: #Error &parents: {Syntax Lexer Error}.
"An error that occurred in parsing, always requiring a description."

p@(Syntax Parser traits) error: description
[
  (p Error newDescription:
    'Line ' ; p lexer lineNumber printString ; ': ' ; description)
   `>> [lineNumber: p lexer lineNumber. signal]
].

p@(Syntax Parser traits) expected: expected butFound: found@(Syntax Token Token traits)
[
  p parseConcatenatively
    ifTrue: [p undoToken: found. p parseUnaryMessage: found]
    ifFalse: [p error: 'Expected ' ; expected signifier  ; ' but found ' ; found signifier]
].

p@(Syntax Parser traits) check: found is: expected@(Syntax Token Token traits)
[(found isSameAs: expected) ifFalse:
  [p expected: expected butFound: found]].

p@(Syntax Parser traits) check: found is: expected@(Sequence traits)
[(expected anySatisfy: #isSameAs: `er <- found) ifFalse:
  [p expected: expected butFound: found]].

p@(Syntax Parser traits) expected: expected@(Sequence traits) butFound: found
[| expectNames |
  p parseConcatenatively
    ifTrue: [^ (p undoToken: found. p parseUnaryMessage: found)].
  expectNames: (expected collect: #signifier `er select: #isNotNil `er).
  expectNames size > 1 ifTrue:
    [expectNames
       at: expectNames indexLast
       put: 'or ' ; expectNames last].
  expectNames:
    (expectNames join &separator:
      (expectNames size = 2 ifTrue: [' '] ifFalse: [', '])).
  p error: 'Expected ' ; expectNames ; ' but found ' ; found signifier
].

p@(Syntax Parser traits) parseOptionalKeywords: expr
[expr].

p@(Syntax Parser traits) parseOptionalKeywords: message@(Syntax Message traits)
[| token opts keywords args |
  opts: (Syntax OptionalKeywords for: message).
  keywords: {} writer.
  args: {} writer.
  [token: p nextToken.
    (token isSameAs: p surroundings Token Selector)
      /\ [p surroundings isOptionalSelector: token selector]]
    whileTrue:
      [keywords nextPut: token selector.
       args nextPut: (p parseBinaryMessage: Nil)].
  opts keywords: keywords contents.
  opts arguments: args contents.
  opts readFrom: p.
  p undoToken: token.
  opts
].

p@(Syntax Parser traits) parseStatement
"Find a complete expression suitable as a statement."
[| expression token |
  expression: p parseExpression.
  token: (p peekToken &interactive: p parseInteractively).
  (token isSameAs: p surroundings Token Selector)
    /\ [p surroundings isOptionalSelector: token selector]
    ifTrue:
      [expression: (p parseOptionalKeywords: expression)].
  expression
].

p@(Syntax Parser traits) next
"The top-level Stream processing to return the next syntax node."
[| statement token |
  statement: p parseStatement.
  p parseInteractively
    ifFalse:
      [token: p nextToken.
       p check: token is: {p surroundings Token EndStatement. p surroundings Token EndStream}].
  statement
    ifNil:
      [p isAtEnd \/ [token isSameAs: p surroundings Token EndStatement]
        ifTrue: [p surroundings Literal Nil readFrom: p]
        ifFalse: [p expected: {p surroundings Token EndStatement. p surroundings Token EndStream}
		    butFound: (p nextToken &interactive: p parseInteractively)]]
].

p@(Syntax Parser traits) parseLiteral
"Take the next token and try to form a literal from it."
[
  p parseLiteral: p nextToken
].

p@(Syntax Parser traits) parseTypeOf: node
[| token oldScope |
  oldScope: p currentScope.
  p currentScope: (p currentScope topLevel for: p typesNamespace).
  [token: (p nextToken &interactive: p parseInteractively). token isSameAs: p surroundings Token Type]
    whileTrue: [node type:
      (p parseAtom
        ifNil: [^ (p error: 'No type given after type declaration marker.')]
        ifNotNilDo: [| :typeExpr | typeExpr evaluateIn: p typesNamespace])].
  p undoToken: token.
  p currentScope: oldScope.
  node
].

p@(Syntax Parser traits) parseAtom
[| token node |
  token: p nextToken.
  node: (p parseAtom: token).
  node
    ifNil: [p undoToken: token. ^ Nil].
  p parseTypeOf: node.
  node
].

p@(Syntax Parser traits) parseUnaryMessage: argument
[| token |
  argument ifNil: [argument: p parseAtom].
  [token: (p nextToken &interactive: p parseInteractively).
    (token is: Syntax Token Selector) /\ [token selector isUnarySelector]]
    whileTrue:
      [| node |
       node: (token messageType sending: token selector to: {argument}).
       node readFrom: p.
       p parseTypeOf: node.
       argument: node].
  p undoToken: token.
  argument
].

p@(Syntax Parser traits) isReturnSelector: s@(Symbol traits)
"Whether the Symbol is a valid return selector in Slate."
[
  (s beginsWith: #^) /\
    [s size = 1 \/ [s size = 2 /\ ['123456789^' includes: s second]]]
].

p@(Syntax Parser traits) parseBinaryMessage: argument
[| token |
  argument: (p parseUnaryMessage: argument).
  [token: (p nextToken &interactive: p parseInteractively).
   (token is: Syntax Token Selector) /\ [token selector isBinarySelector]]
    whileTrue:
      [argument: ((p isReturnSelector: token selector) /\ [argument isNil]
          ifTrue: "Handle return expressions."
            [(token selector caseOf:
	      {#^ -> [p surroundings ReturnClose].
	       #^^ -> [p surroundings ReturnFar]}
		otherwise: [p surroundings ReturnLevel by:
		  (Integer readFrom: token selector allButFirst)])
	      of: (p parseUnaryMessage: Nil)]
          ifFalse:
            [token messageType
              sending: token selector
              to: {argument ifNil: [p surroundings ImplicitArgument].
                   (p parseUnaryMessage: Nil)
                     ifNil: [p error: 'Only the first argument to a binary message may be implicit']}]).
       argument readFrom: p].
  p undoToken: token.
  argument
].

p@(Syntax Parser traits) parseKeywordMessage: argument
"Handles all keyword-message-send forms."
[| front token arguments selector |
  argument: (p parseBinaryMessage: argument).
  token: (p peekToken &interactive: p parseInteractively).
  (token is: p surroundings Token Selector) /\ [token selector isKeywordSelector]
    ifFalse: [^ argument].
  arguments:
    ([| :result |
      result nextPut: (argument ifNil: [Syntax ImplicitArgument]).
      [token: (p nextToken &interactive: p parseInteractively). 
       (token is: Syntax Token Selector)
	 /\ [token selector isOptionalSelector not]]
         whileTrue:
	   [front ifNil: [front: token].
	    token selector isKeywordSelector
	      ifFalse: [p error: 'Bad keyword message'].
            selector: (selector
              ifNil: [token selector name]
              ifNotNil: [selector ; token selector name]).
            result nextPut: 
              ((p parseBinaryMessage: Nil)
                 ifNil: [p error: 'Only the first argument to a keyword message may be implicit'])].
      p undoToken: token] writingAs: {}).
  arguments first == Syntax ImplicitArgument /\ [arguments size = 2]
    ifTrue:
      [(p currentScope 
          findVariable: 
            (selector 
              copyFrom: 0 
              to: selector size - 2) intern)
        ifNotNilDo:
          [| :variable |
           ^ ((Syntax StoreVariable of: arguments second
               into: variable) readFrom: p)]].
  selector: selector intern.
  (front messageType sending: selector to: arguments) readFrom: p
].

p@(Syntax Parser traits) parseBlock: block
[| interactive token statements lineNumber inputVariables optKeywords optVariables |
  interactive: p parseInteractively.
  p parseInteractively: False.
  lineNumber: p lexer lineNumber.
  inputVariables: {} writer.
  optKeywords: {} writer.
  optVariables: {} writer.
  block parentScope: p currentScope.
  p currentScope: block.
  token: p nextToken.
  (token isSameAs: p surroundings Token BeginVariables)
    ifTrue:
      [token: p nextToken.
       [token isSameAs: p surroundings Token EndVariables]
         whileFalse:
           [| variable name tmpName |
            (token isSameAs: p surroundings Token Selector)
              ifFalse:
                [p error: 'Bad variable declaration'].
            name: token selector.
            (p surroundings isUnarySelector: name)
              ifTrue:
                [(block localVariables detect:
                  [| :var | var name = name /\ [name ~= #_]])
                    ifNil: 
                      [variable: Syntax Variable clone `>>
			 [scope: block. name: name. ]. ]
                    ifNotNilDo: 
                      [| :var | variable: var]]
              ifFalse:
                [tmpName: name name.
                 (':&*' includes: tmpName first)
                   ifFalse:
                     [p error: 'Bad input variable declaration: ' ; name name].
         variable: Syntax Variable clone `>> [scope: block. ].
         tmpName first
           caseOf:
             {
               $* -> [
                       tmpName: tmpName allButFirst intern. 
                       tmpName isUnarySelector
                         ifFalse:
                           [p error: 'Bad rest variable declaration: ' ; name name].
                       tmpName ~= #_ 
                         /\ [block localVariables anySatisfy: [| :var | var name = tmpName]]
                         ifTrue: [p error: 'Variable already declared: ' ; tmpName name].
                       variable name: tmpName.
                       block restVariable: variable
                     ].
               $: -> [
                       tmpName: tmpName allButFirst intern.
                       tmpName isUnarySelector
                         ifFalse:
                           [p error: 'Bad input variable declaration: ' ; name name].
                       tmpName ~= #_ /\ 
                         [block localVariables anySatisfy: [| :var | var name = tmpName]]
                         ifTrue: [p error: 'Variable already declared: ' ; tmpName name].
                       variable name: tmpName. 
                       inputVariables nextPut: variable
                     ].
               $& -> [
                       tmpName: tmpName allButFirst intern.
                       tmpName isUnarySelector
                         ifFalse:
                           [p error: 'Bad keyword declaration: ' ; name name].
                       tmpName ~= #_ 
                         /\ [block localVariables anySatisfy: [| :var | var name = tmpName]]
                         ifTrue: [p error: 'Variable already declared: ' ; tmpName name].
                       variable name: tmpName.
                       optKeywords nextPut: name.
                       optVariables nextPut: variable
                     ]
             }].
            p parseTypeOf: variable.
            token: p nextToken.
            variable name = #_ \/ [block localVariables noneSatisfy: [| :var | var name = variable name]]
              ifTrue: [block localVariables: block localVariables ; { variable }]]]
    ifFalse:
      [p undoToken: token].
  block inputVariables: block inputVariables ; inputVariables contents.
  block optionalKeywords: block optionalKeywords ; optKeywords contents.
  block optionalVariables: block optionalVariables ; optVariables contents.
  "Defines the order of locals: inputs, optionals, rest, then non-optional
   locals."
  block localVariables:
    block inputVariables ;
    block optionalVariables ;
    (block restVariable ifNil: [{}] ifNotNil: [{block restVariable}]) ;
    (block localVariables select:
      [| :var |
       (block inputVariables includes: var) not
         /\ [(block optionalVariables includes: var) not]
         /\ [block restVariable ~== var]]).
  statements: {} writer.
  statements nextPut: (p parseStatement ifNil: [p surroundings Literal Nil readFrom: p]).
  [token: p nextToken. token isSameAs: p surroundings Token EndBlock]
    whileFalse:
      [p check: token is: {Syntax Token EndStatement. Syntax Token EndBlock}.
        statements nextPut: (p parseStatement ifNil: [(Syntax Literal for: Nil) readFrom: p])].
  p parseInteractively: interactive.
  p currentScope: block parentScope.
  block statements: statements contents.
  block
].

p@(Syntax Parser traits) parseDefinition
[| selector roles inputVariables optKeywords optVariables opts token method |
  selector: Nil.
  roles: {} writer.
  inputVariables: {} writer.
  optKeywords: {} writer.
  optVariables: {} writer.
  opts: False.
  method: p surroundings MethodDefinition new.
  method readFrom: p.
  [token: p nextToken. token isSameAs: p surroundings Token BeginBlock]
    whileFalse:
      [| variable |
       (token isSameAs: p surroundings Token Selector)
         /\ [token selector isUnarySelector]
           ifFalse: [p error: 'Bad input variable name in method definition'].
       variable: p surroundings Variable clone `>>
	 [readFrom: p. name: token selector. scope: method. ].
       token: p nextToken.
       opts
         ifTrue:
           [optVariables nextPut: variable.
            (token isSameAs: p surroundings Token Selector)
              /\ [p surroundings isOptionalSelector: token selector]
              ifTrue:
                [optKeywords nextPut: token selector]
              ifFalse:
                [(token isSameAs: p surroundings Token BeginBlock)
                  ifFalse:
                    [p error: 'Bad optional keyword in method definition'].
                 p undoToken: token]]
         ifFalse:
           [inputVariables nextPut: variable.
            (token isSameAs: p surroundings Token At)
              ifTrue:
                [roles nextPut: p parseAtom. token: p nextToken]
              ifFalse:
                [roles nextPut: ((Syntax Literal for: NoRole) readFrom: p)].
            (token isSameAs: p surroundings Token Selector)
              ifTrue:
                [selector isNotNil
                   /\ [token selector isOptionalSelector not]
                   /\ [selector isKeywordSelector not 
                   \/ [token selector isKeywordSelector not]]
                  ifTrue:
                    [p error: 'Bad selector name in method definition'].
                 (p surroundings isUnarySelector: token selector)
                  ifTrue:
                    [selector: token selector.
                     (p peekToken isSameAs: p surroundings Token Selector)
                       /\ [p surroundings isOptionalSelector: p peekToken selector]
                       ifTrue: [token: p nextToken]].
                 (p surroundings isBinarySelector: token selector)
                  ifTrue:
                    [selector: token selector].
                 (p surroundings isKeywordSelector: token selector)
                  ifTrue:
                    [selector:
                      (selector
                         ifNil: [token selector]
                         ifNotNil: [(selector name ; token selector name) intern])].
                 (p surroundings isOptionalSelector: token selector)
                  ifTrue:
                    [optKeywords nextPut: token selector.
                     opts: True]]
              ifFalse:
                [(token isSameAs: p surroundings Token BeginBlock)
                   ifFalse:
                     [p error: 'Bad selector name in method definition'].
                 p undoToken: token]].
       method localVariables: method localVariables ; {variable}].
  selector ifNil: [p error: 'No selector name specified in method definition'].
  method selector: selector.
  method roles: roles contents.
  method inputVariables: inputVariables contents.
  method optionalKeywords: optKeywords contents.
  method optionalVariables: optVariables contents.
  "method"
  p parseBlock: method
].

p@(Syntax Parser traits) parseExpression
[| token index |
  index: 0.
  [token: (index < p lookAheadBuffer size
             ifTrue: [p lookAheadBuffer at: index]
             ifFalse: [p bufferToken]).
   index: index + 1.
   (token isSameAs: Syntax Token BeginVariables)
      ifTrue: [^ (p error: 'Block headers are not valid expressions.')].
   (token isSameAs: p surroundings Token At)
      ifTrue: [^ (p parseKeywordMessage: (p parseTypeOf: p parseDefinition))].
   (token isSameAs: Syntax Token Selector) \/
     [token isSameAs: Syntax Token Comment] \/
     [p parseInteractively not \/ [index = 1] /\ [token isSameAs: Syntax Token EndLine]]]
    whileTrue.
  p parseKeywordMessage: Nil
].
