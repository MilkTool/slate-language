Image ensureNamespace: #Bootstrap.

"fixme: this is overwritten everytime you make a new generator"
Image Bootstrap define: #BytesPerWord -> 4.
"The size of a word in bytes on the target platform."
"TODO: Make this an attribute of an accessible target description."

Image Bootstrap define: #Chunk &parents: {Cloneable} &slots: {#oop}.

_@(Image Bootstrap Chunk traits) wordSize [overrideThis].

Image Bootstrap define: #SlotEntry &parents: {Cloneable} &slots: {#name. #offset}.

se@(Image Bootstrap SlotEntry traits) newNamed: name offset: offset
[se clone `>> [name := name. offset := offset. ]].

Image Bootstrap define: #RoleEntry &parents: {Cloneable} &slots:
  {#name. #rolePositions -> 0. #methodDefinition}.

re@(Image Bootstrap RoleEntry traits) newNamed: name rolePositions: positions methodDefinition: method
[re clone `>>
   [name := name. rolePositions := positions. methodDefinition := method. ]].

Image Bootstrap define: #MethodDefinition &parents: {Cloneable} &slots:
  {#dispatchPositions -> 0. #method. #slotAccessor}.

md@(Image Bootstrap MethodDefinition traits) newDispatchPositions: positions method: method
[md clone `>> [dispatchPositions := positions. method := method. ]].

Image Bootstrap define: #Map &parents: {Cloneable} &slots:
  {#flags -> 0. #representative -> Nil.
   #delegates -> {}.
   #slotCount -> 0.
   #slotTable -> {}.
   #roleTable -> {}}.

map@(Image Bootstrap Map traits) addSlotNamed: name at: offset
[
  map slotTable infect: #clone `er.
  map slotTable := (map slotTable copyWith: (map surroundings SlotEntry newNamed: name offset: offset)).
  map
].

map@(Image Bootstrap Map traits) addRoleNamed: name at: position dispatching: def
[
  map roleTable
    doWithIndex:
      [| :role :index |
       role methodDefinition == def
         ifTrue:
           [map roleTable := map roleTable copy.
            map roleTable at: index :=
              (map surroundings RoleEntry
                 newNamed: name
                 rolePositions: (role rolePositions bitOr: (1 bitShift: position))
                 methodDefinition: def).
            ^ False]].
  map roleTable :=
    map roleTable copyWith:
      (map surroundings RoleEntry
         newNamed: name
         rolePositions: (1 bitShift: position)
         methodDefinition: def).
  True
].

Image Bootstrap define: #Object &parents: {Image Bootstrap Chunk} &slots:
  {#idHash. #bmap -> Image Bootstrap Map. #slotValues -> {}}.

_@(Image Bootstrap Object traits) headerWords
[4].

obj@(Image Bootstrap Object traits) wordSizeSansPayload
[obj headerWords + obj slotValues size].

obj@(Image Bootstrap Object traits) wordSize
[obj wordSizeSansPayload].

obj@(Image Bootstrap Object traits) makeSlotNamed: name valued: value
[| index |
  index := obj bmap slotCount.
  obj bmap := obj bmap clone `>>
    [slotCount := index + 1.
     addSlotNamed: name at: obj headerWords + index * obj surroundings BytesPerWord. ].
  obj slotValues := (obj slotValues copyWith: value).
  obj
].

obj@(Image Bootstrap Object traits) addDelegateValued: value
[
  obj bmap := obj bmap clone `>>
    [delegates := obj bmap delegates copyWith: value. ].
  obj
].

obj@(Image Bootstrap Object traits) addRoleNamed: name at: position dispatching: def
[
  obj bmap addRoleNamed: name at: position dispatching: def
].

obj@(Image Bootstrap Object traits) setSlot: name to: val
[
  obj bmap slotTable
    do: [| :slot | slot name = name ifTrue:
      [^ (obj slotValues at: slot offset / obj surroundings BytesPerWord - obj headerWords put: val)]].
  Nil
].

obj@(Image Bootstrap Object traits) setSlots: namesAndValues
[
  namesAndValues do: [| :assoc | obj setSlot: assoc key to: assoc value]
].

obj@(Image Bootstrap Object traits) getSlot: name
[
  obj bmap slotTable
    do: [| :slot | slot name = name ifTrue:
      [^ (obj slotValues at: slot offset / obj surroundings BytesPerWord - obj headerWords)]].
  Nil
].

method@(Image Bootstrap Object traits) addMethodNamed: name on: roles
[| def |
  def := method surroundings MethodDefinition newDispatchPositions: 0 method: method.
  roles doWithIndex:
    [| :role :index |
      role ifNotNil:
        [def dispatchPositions := def dispatchPositions bitOr: (1 bitShift: index).
         role addRoleNamed: name at: index dispatching: def]].
  "inform: 'Adding method %r roles: %r pos: %r', name, roles, def dispatchPositions."
  def
].

Image Bootstrap define: #Array &parents: {Image Bootstrap Object}.

Image Bootstrap define: #OopArray &parents: {Image Bootstrap Array}
  &slots: {#elements -> {}}.

arr@(Image Bootstrap OopArray traits) wordSize
[arr wordSizeSansPayload + arr elements size].

Image Bootstrap define: #ByteArray &parents: {Image Bootstrap Array}
  &slots: {#elements -> ByteArray new}.

arr@(Image Bootstrap ByteArray traits) byteSize
[
  arr wordSizeSansPayload * arr surroundings BytesPerWord + arr elements size
].

arr@(Image Bootstrap ByteArray traits) wordSize
[
  arr wordSizeSansPayload + (arr elements size + arr surroundings BytesPerWord - 1 // arr surroundings BytesPerWord)
].

Image Bootstrap define: #CompiledMethod &parents: {Image Bootstrap Object}.

Image Bootstrap define: #Generator &parents: {Cloneable} &slots: {
  #translations -> IdentityDictionary new.
  #chunks -> ExtensibleArray new.
  #characters -> (Array newSizeOf: ASCIIString Character CharacterSet).
  #symbols -> Dictionary new.
  #littleEndian -> True.
  #bytesPerWord -> Image Bootstrap BytesPerWord.
  #nextHash -> 0.
  #imageSize -> 0.
  #objects -> Dictionary new.
}.

gen@(Image Bootstrap Generator traits) new &littleEndian: littleEndian &wordSize: wordSize
[
  littleEndian `defaultsTo: gen littleEndian.
  wordSize `defaultsTo: Platform Current bytesPerWord * 8.
  Image Bootstrap define: #BytesPerWord -> (wordSize // 8).
  gen clone `setting:
    #{#objects. #translations. #chunks. #characters. #symbols. #bytesPerWord. #littleEndian}
    to: {gen objects new.
	 gen translations new.
	 gen chunks new.
	 gen characters copy.
	 gen symbols new.
         wordSize // 8.
	 littleEndian}
].

gen@(Image Bootstrap Generator traits) generateImageBooting: method withPrims: prims
"Generates the primary image objects such that the supplied CompiledMethod
will be interpreted immediately upon loading the image."
[
  inform: 'Generating kernel'.
  gen generateKernel.
  inform: 'Generating utilities'.
  gen generateUtilities.
  inform: 'Generating kernel accessors'.
  gen generateKernelAccessors.
  inform: 'Generating interpreter'.
  gen generateInterpreterBooting: method.
  inform: 'Generating lobby'.
  gen generateLobby.
  inform: 'Generating prims'.
  prims do: [| :assoc | gen generatePrimitive: assoc value at: assoc key].
  inform: 'Generating maps'.
  gen generateMaps.
  inform: 'Generating linkage'.
  gen generateLinkage
].

gen@(Image Bootstrap Generator traits) objectNamed: name
[gen objects at: name].

gen@(Image Bootstrap Generator traits) bytesAt: i in: arr put: val numBytes: bytes
[
  0 below: bytes do:
    [| :index |
     arr elements at: i + index put:
       (val byteShift: (gen littleEndian ifTrue: [0 - index]
                                         ifFalse: [0 - bytes + index])) intoByte]
].

gen@(Image Bootstrap Generator traits) shortAt: i in: arr put: val
[
  gen bytesAt: i in: arr put: val numBytes: gen bytesPerWord // 2
].

gen@(Image Bootstrap Generator traits) longAt: i in: arr put: val
[
  gen bytesAt: i in: arr put: val numBytes: gen bytesPerWord
].

gen@(Image Bootstrap Generator traits) generateSlotTableFor: map
[| obj capacity selector hash |
  capacity := (map slotTable size * 5 // 4) leastGreaterPowerOfTwo.
  obj := (gen cloneOf: (gen objectNamed: #ArrayProto) sized: 2 * capacity).
  map slotTable do:
    [| :se |
      selector := (gen generateLiteral: se name).
      hash := (selector idHash bitAnd: capacity - 1) * 2.
      [(obj elements at: hash) isNil]
        whileFalse:
          [hash := (hash + 2) \\ (capacity * 2)].
      obj elements at: hash put: selector.
      obj elements at: hash + 1 put: se offset
    ].
  obj
].

gen@(Image Bootstrap Generator traits) generateRoleTableFor: map
[| obj capacity selector hash insert |
  capacity := (map roleTable size * 5 // 4) leastGreaterPowerOfTwo.
  obj := (gen cloneOf: (gen objectNamed: #ArrayProto) sized: 4 * capacity).
  map roleTable do:
    [| :re |
      selector := (gen generateLiteral: re name).
      hash := (selector idHash bitAnd: capacity - 1) * 4.
      [(obj elements at: hash) isNil
        \/ [(obj elements at: hash) == selector]]
        whileFalse:
          [hash := (hash + 4) \\ (capacity * 4)].
      insert := hash.
      [(obj elements at: insert) isNil]
        whileFalse:
          [insert := (insert + 4) \\ (capacity * 4)].
      obj elements at: insert put: selector.
      obj elements at: insert + 1 put: re rolePositions.
      obj elements at: insert + 2 put: (gen generateMethodDef: re methodDefinition).
      insert == hash
        ifFalse:
          [[(obj elements at: hash + 3) isNil]
              whileFalse: [hash := (obj elements at: hash + 3) * 4].
           obj elements at: hash + 3 put: insert // 4]].
  obj
].

gen@(Image Bootstrap Generator traits) generateMethodDef: def
[
  gen translations at: def
    ifAbsentPut:
      [| obj sym |
        sym := (def method getSlot: #selector).
        sym setSlot: #cacheMask to: ((sym getSlot: #cacheMask) bitOr: def dispatchPositions).
        obj := (gen cloneOf: (gen objectNamed: #MethodDefinitionProto)).
        obj setSlots: {
          #method -> def method.
          #slotAccessor -> (gen generateLiteral: def slotAccessor)
        }.
        gen longAt: 1 * gen bytesPerWord in: obj put: def dispatchPositions.
        obj]
].

gen@(Image Bootstrap Generator traits) generateMap: map
[
  gen translations at: map
    ifAbsentPut:
      [(gen cloneOf: (gen objectNamed: #MapProto)) `>>
         [setSlots: {#flags -> map flags.
                     #representative -> (map representative ifNil: [gen objectNamed: #NilObject]).
                     #delegates -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: map delegates).
                     #slotCount -> map slotCount.
                     #slotTable -> (gen generateSlotTableFor: map).
                     #roleTable -> (gen generateRoleTableFor: map)}. ]]
].

gen@(Image Bootstrap Generator traits) generateMaps
[
  gen objects keysAndValuesDo:
    [| :name :obj |
     inform: ' Adding map for %s', name.
     gen generateMap: obj bmap]
].

obj@(Image Bootstrap Object traits) nextOop
"Answer the pointer to just beyond this object."
[obj oop + (obj wordSize * obj surroundings BytesPerWord)].

gen@(Image Bootstrap Generator traits) assignOops
"Assign oops to all of the chunks, accumulating the final oop which is used
to set the image size."
[
  gen imageSize := (gen chunks inject: 0 into:
    [| :oop :chunk | chunk oop := oop. chunk nextOop])
].

gen@(Image Bootstrap Generator traits) emitInteger: val on: stream byteSize: byteSize
"Takes an integer and outputs the binary data value in the correct byte-order
onto the stream."
[
  stream next: byteSize putInteger: val &littleEndian: gen littleEndian
].

gen@(Image Bootstrap Generator traits) emitLong: val on: stream
"Takes an integer and outputs the binary data value in the correct byte-order
onto the stream."
[
  gen emitInteger: val on: stream byteSize: gen bytesPerWord
].

gen@(Image Bootstrap Generator traits) emitOopOf: chunk on: stream
[gen emitLong: chunk oop on: stream].

gen@(Image Bootstrap Generator traits) emitOopOf: _@Nil on: stream
[gen emitOopOf: (gen objectNamed: #NilObject) on: stream].

gen@(Image Bootstrap Generator traits) emitOopOf: i@(SmallInteger traits) on: stream
[gen emitLong: (i << 1 bitOr: 1) on: stream].

gen@(Image Bootstrap Generator traits) emitObjectHashed: hash sized: size payload: payload format: format on: stream
[
  "fix: check big endian"
  "header"
  (gen littleEndian not) ifTrue: [ gen emitInteger: 0 on: stream byteSize: gen bytesPerWord - 4].
  stream nextPutAll:
    ((gen littleEndian
      ifTrue:
        [{2r1 bitOr: (hash bitAnd: 16r7F) << 1.
          (hash >> 7) intoByte.
          (hash >> 15) intoByte.
          format << 6}]
      ifFalse:
        [{2r10000000 bitOr: (hash >> 16 bitAnd: 16r7F).
          (hash >> 8) intoByte.
          hash intoByte.
          format}]) as: ByteArray).
  (gen littleEndian) ifTrue: [ gen emitInteger: 0 on: stream byteSize: gen bytesPerWord - 4].

  "size in words of slot data"
  gen emitLong: size on: stream.
  "size in bytes of payload (oop array or byte array)"
  gen emitLong: payload on: stream.  



  stream
].

gen@(Image Bootstrap Generator traits) emit: obj@(Image Bootstrap Object traits) on: stream
[
  gen emitObjectHashed: obj idHash sized: obj wordSize payload: 0 format: 2r00 on: stream.
  gen emitLong: (gen translations at: obj bmap) oop on: stream.
  obj slotValues
    do: [| :slotVal | gen emitOopOf: slotVal on: stream].
  obj
].

gen@(Image Bootstrap Generator traits) emit: obj@(Image Bootstrap OopArray traits) on: stream
[
  gen emitObjectHashed: obj idHash
    sized: obj wordSizeSansPayload
    payload: obj elements size * gen bytesPerWord
    format: 2r01
    on: stream.
  gen emitLong: (gen translations at: obj bmap) oop on: stream.
  (obj slotValues ;; obj elements)
    do: [| :slotVal | gen emitOopOf: slotVal on: stream].
  obj
].

gen@(Image Bootstrap Generator traits) emit: obj@(Image Bootstrap ByteArray traits) on: stream
[
  gen emitObjectHashed: obj idHash
    sized: obj wordSizeSansPayload
    payload: obj elements size
    format: 2r10
    on: stream.
  gen emitLong: (gen translations at: obj bmap) oop on: stream.
  obj slotValues do: [| :slotVal | gen emitOopOf: slotVal on: stream].
  stream nextPutAll: obj elements.
  stream next: (gen bytesPerWord - obj elements size) \\ gen bytesPerWord put: 0.
  obj
].

gen@(Image Bootstrap Generator traits) emitHeaderOn: stream
[
  gen emitLong: 16rABCDEF43 on: stream.
  gen emitLong: gen imageSize on: stream.
  gen emitLong: gen nextHash on: stream.
  gen emitLong: ((gen objectNamed: #GlobalsObject) getSlot: #specialOops) oop on: stream.
"i shortened dispatch id to one word"
  gen emitLong: 0 on: stream.

].

gen@(Image Bootstrap Generator traits) emitOn: stream
"Emits a bootstrap image on the stream after it has been generated."
[
  inform: 'Assigning oops'.
  gen assignOops.
  inform: 'Emitting image: %s', stream resource locator.
  gen emitHeaderOn: stream.
  gen chunks do: [| :chunk | gen emit: chunk on: stream]
].

gen@(Image Bootstrap Generator traits) addObjectNamed: name valued: obj
[
  inform: ' Adding object %s', name.
  gen objects at: name put: obj.
  obj
].

gen@(Image Bootstrap Generator traits) newIdentityHash
[| hash |
  hash := gen nextHash.
  gen nextHash := gen nextHash + 1.
  hash
].

gen@(Image Bootstrap Generator traits) new: layout fromMap: map
[| obj |
  obj := layout clone `>> [idHash := gen newIdentityHash. bmap := map. ].
  obj slotValues := (obj slotValues newSize: map slotCount).
  map representative := obj.
  gen chunks addLast: obj.
  obj
].

gen@(Image Bootstrap Generator traits) newMap
[
  gen surroundings Map clone
].

gen@(Image Bootstrap Generator traits) newObject
[
  gen new: gen surroundings Object
].

gen@(Image Bootstrap Generator traits) new: layout
[
  gen new: layout fromMap: gen newMap
].

gen@(Image Bootstrap Generator traits) cloneOf: proto@(Image Bootstrap Object traits)
[
  gen chunks addLast: proto clone `>>
    [idHash := gen newIdentityHash. slotValues := proto slotValues copy. ]
].

gen@(Image Bootstrap Generator traits) cloneOf: arr@(Image Bootstrap Array traits)
[resend `>> [elements := arr elements copy. ]].

gen@(Image Bootstrap Generator traits) cloneOf: proto sized: size
[(gen cloneOf: proto) `>> [elements := (proto elements newSize: size). ]].

gen@(Image Bootstrap Generator traits) cloneOf: proto elements: elements
[(gen cloneOf: proto) `>> [elements := (elements as: proto elements). ]].

gen@(Image Bootstrap Generator traits) addAccessorFor: slotName on: obj
[| accessor selector |
  selector := (obj accessorNameFor: slotName).
  accessor := (gen cloneOf: (gen objectNamed: #CompiledMethodProto)).
  accessor setSlots: {
    #method -> accessor.
    #selector -> (gen generateLiteral: selector).
    #inputVariables -> 1.
    #localVariables -> 1.
    #registerCount -> 3.
    #literals -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: slotName}).
    #selectors -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: #atSlotNamed:}).
    #code ->
    (gen cloneOf: (gen objectNamed: #ArrayProto)
      elements: {
        VM SSACode loadVariable. 0.
        VM SSACode loadLiteral. 1. gen generateLiteral: slotName.
        VM SSACode directSendMessage. 0. gen generateLiteral: #atSlotNamed:. 2. 0. 1.
        VM SSACode returnRegister. 0
      })
  }.
  (accessor addMethodNamed: selector on: {obj}) slotAccessor: slotName.
  accessor
].

gen@(Image Bootstrap Generator traits) addMutatorFor: slotName on: obj
[| mutator selector |
  mutator := (gen cloneOf: (gen objectNamed: #CompiledMethodProto)).
  selector := (obj mutatorNameFor: slotName).
  mutator setSlots: {
    #method -> mutator.
    #selector -> (gen generateLiteral: selector).
    #inputVariables -> 2.
    #localVariables -> 1.
    #registerCount -> 4.
    #literals -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: slotName}).
    #selectors -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: #atSlotNamed:put:}).
    #code ->
    (gen cloneOf: (gen objectNamed: #ArrayProto)
      elements:
        {
          VM SSACode loadVariable. 0.
          VM SSACode loadVariable. 1.
          VM SSACode loadLiteral. 2. gen generateLiteral: slotName.
          VM SSACode directSendMessage. 0. gen generateLiteral: #atSlotNamed:put:. 3. 0. 2. 1.
          VM SSACode returnRegister. 0
        })
  }.
  (mutator addMethodNamed: selector on: {obj. Nil}) slotAccessor: slotName.
  mutator
].

gen@(Image Bootstrap Generator traits) addAccessorsFor: slotName on: obj
[
  gen addAccessorFor: slotName on: obj.
  gen addMutatorFor: slotName on: obj
].

gen@(Image Bootstrap Generator traits) generateKernelAccessors
[
  gen objects do:
    [| :obj |
     obj bmap slotTable do: [| :slot | gen addAccessorsFor: slot name on: obj]]
].

gen@(Image Bootstrap Generator traits) generatePrototype: name &suffix: suffix &layout: layout &parents: parents &slots: slotSpecs &elements: elements
[| traits window result |
  suffix `defaultsTo: 'Proto'.
  slotSpecs `defaultsTo: {}.
  traits := (gen addObjectNamed: (name ; 'Traits') intern valued: gen newObject)
    `>> [addDelegateValued: Nil. ].
  window := (gen addObjectNamed: (name ; 'Window') intern valued: gen newObject)
    `>> [bmap flags := 1. addDelegateValued: Nil. ].
  parents
    ifNotNil:
      [parents reverseDoWithIndex:
        [| :parent :index |
          window addDelegateValued: parent]].
  window addDelegateValued: traits.
  result := (gen addObjectNamed: (name ; suffix) intern
	       valued: (layout ifNil: [gen newObject] ifNotNil: [gen new: layout]))
    `>> [addDelegateValued: window. ].
  elements ifNotNil:
    [(result hasSlotNamed: #elements) ifTrue: [result elements := elements]].
  slotSpecs do:
    [| :spec | result makeSlotNamed: spec key valued: spec value].
  result
].

gen@(Image Bootstrap Generator traits) generateInstance: name of: window
[(gen addObjectNamed: name valued: gen newObject) `>>
  [addDelegateValued: window.]
].

gen@(Image Bootstrap Generator traits) generateKernel
[
  gen generatePrototype: 'Root'.
  gen generatePrototype: 'Oddball' &parents: {gen objectNamed: #RootTraits}.
  gen generatePrototype: 'Derivable' &parents: {gen objectNamed: #RootTraits}.
  gen generatePrototype: 'Cloneable' &parents: {gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.

  gen generateInstance: #NilObject of: (gen objectNamed: #OddballWindow).
  gen generateInstance: #NoRoleObject of: (gen objectNamed: #OddballWindow).

  gen generatePrototype: 'Boolean' &parents: {gen objectNamed: #OddballTraits. gen objectNamed: #RootTraits}.
  gen generateInstance: #TrueObject of: (gen objectNamed: #BooleanWindow).
  gen generateInstance: #FalseObject of: (gen objectNamed: #BooleanWindow).

  gen generatePrototype: 'Array' &layout: gen surroundings OopArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &elements: Array new.
  gen generatePrototype: 'ByteArray' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &elements: ByteArray new.

  gen generatePrototype: 'SmallInteger' &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #OddballTraits. gen objectNamed: #RootTraits}.
  (gen generatePrototype: 'Float' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #ByteArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}) `>>
    [elements: (ByteArray newSize: gen bytesPerWord)].

  gen generatePrototype: 'ASCIIString' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #ByteArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.

  gen generatePrototype: 'Symbol' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #ASCIIStringTraits. gen objectNamed: #NilObject. gen objectNamed: #ByteArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#cacheMask -> 0}.

  gen symbols at: #'' put: (gen objectNamed: #SymbolProto).

  gen generatePrototype: 'ASCIICharacter'
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #OddballTraits. gen objectNamed: #RootTraits} &slots: {#code -> 0}.
  gen characters at: 0 put: (gen objectNamed: #ASCIICharacterProto).
  1 below: gen characters size
    do: [| :index c |
      c: (gen cloneOf: (gen objectNamed: #ASCIICharacterProto)).
      c setSlot: #code to: index.
      gen characters at: index put: c].
  (gen objectNamed: #ASCIIStringTraits) makeSlotNamed: #Character valued: (gen objectNamed: #ASCIICharacterProto).

  gen generatePrototype: 'Namespace'
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.
  gen generateInstance: #BootstrapObject of: (gen objectNamed: #NamespaceWindow).

  gen generatePrototype: 'Method' &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.

  gen generatePrototype: 'PrimitiveMethod'
    &parents: {gen objectNamed: #MethodTraits. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#index -> 0. #selector -> (gen objectNamed: #NilObject). #inputVariables -> 0}.

  gen generatePrototype: 'CompiledMethod'
    &parents: {gen objectNamed: #MethodTraits. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#method -> (gen objectNamed: #NilObject). #selector -> (gen objectNamed: #NilObject).
	#inputVariables -> 0. #localVariables -> 0.
	#restVariable -> (gen objectNamed: #FalseObject).
	#optionalKeywords -> (gen objectNamed: #ArrayProto).
	#heapAllocate -> (gen objectNamed: #FalseObject).
	#environment -> (gen objectNamed: #BootstrapObject).
	#literals -> (gen objectNamed: #ArrayProto).
	#selectors -> (gen objectNamed: #ArrayProto).
	#code -> (gen objectNamed: #ArrayProto).
	#sourceTree -> (gen objectNamed: #NilObject).
	#debugMap -> (gen objectNamed: #ArrayProto).
        #isInlined -> (gen objectNamed: #FalseObject).
        #oldCode -> (gen objectNamed: #NilObject).
        #callCount -> 0.
        #calleeCount -> (gen objectNamed: #NilObject).
        #registerCount -> 0.
        #cachedInCallers -> (gen objectNamed: #NilObject).
        #cachedInCallersCount -> 0.
        #nextInlineAtCallCount -> (gen objectNamed: #NilObject).
        #reserved5 -> (gen objectNamed: #NilObject).
        #reserved6 -> 0}.

  gen generatePrototype: 'Closure' &layout: gen surroundings OopArray
    &parents: {gen objectNamed: #MethodTraits. gen objectNamed: #ArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#method -> (gen objectNamed: #NilObject)}.

  gen generatePrototype: 'MethodDefinition' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#method -> (gen objectNamed: #CompiledMethodProto). #slotAccessor -> (gen objectNamed: #NilObject)}
    &elements: (ByteArray newSize: 4 * gen bytesPerWord).

  gen generatePrototype: 'Map' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#flags -> 0. #representative -> (gen objectNamed: #NilObject).
     #delegates -> (gen objectNamed: #ArrayProto). #slotCount -> 0.
     #slotTable -> (gen objectNamed: #ArrayProto). #roleTable -> (gen objectNamed: #ArrayProto)}
    &elements: (ByteArray newSize: 3 * gen bytesPerWord).

  gen generatePrototype: 'LexicalContext' &layout: gen surroundings OopArray
    &parents: {gen objectNamed: #ArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#framePointer -> 0}.

  gen generatePrototype: 'Interpreter' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#stack -> (gen objectNamed: #ArrayProto).
     #method -> (gen objectNamed: #NilObject).
     #closure -> (gen objectNamed: #NilObject).
     #lexicalContext -> (gen objectNamed: #NilObject).
     #ensureHandlers -> 0}
    &elements: (ByteArray newSize: 5 * gen bytesPerWord).

  (gen addObjectNamed: #EnsureMarkerObject valued: (gen cloneOf: (gen objectNamed: #CompiledMethodProto))) `>>
    [| :marker |
      setSlot: #method to: marker.
      setSlot: #code to:
        (gen cloneOf: (gen objectNamed: #ArrayProto)
          elements: {VM SSACode resume})].
].

gen@(Image Bootstrap Generator traits) generateInterpreterBooting: method
[| compiler stackObj stackSize methodObj codeSize |
  compiler := VM SSACompiler new.
  _@compiler branchTableHash: key
  [| literal |
    literal := (gen generateLiteral: key).
    (literal isSameAs: SmallInteger)
      ifTrue: [literal]
      ifFalse: [literal idHash]
  ].
  inform: 'Compiling the syntax tree of bootstrap code and libraries into SSA code.'.
  
  method := (compiler generate: method result: Nil &topLevel: True) `>> [heapAllocate := False. ].

  "compiler decompile: method code."

  methodObj := (gen generateLiteral: method).

  stackSize := 16. "if you change this, change vm.c which has it hard-coded in the beginning of interpret()"

  stackObj := (gen cloneOf: (gen objectNamed: #ArrayProto) sized: stackSize) `>>
    [elements at: 0 put: 0. "-6: prev sp"
     elements at: 1 put: -1. "-5: resultStackPointer"
     elements at: 2 put: 0. "-4: code pointer"
     elements at: 3 put: methodObj. "-3: closure"
     elements at: 4 put: 0. "-2: lexical context"
     elements at: 5 put: 0. "-1: prev fp"
     elements at: 6 put: 0. ].

  codeSize := method code size.

  gen addObjectNamed: #InterpreterObject valued: (gen cloneOf: (gen objectNamed: #InterpreterProto)).
  (gen objectNamed: #InterpreterObject) setSlots: {
    #stack -> stackObj.
    #method -> methodObj.
    #closure -> methodObj
  }.
  gen longAt: 0 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: 6. " frame pointer (framesize=6)"
  "long at 1 is code pointer -- I guess this gets filled later or is zero"
  gen longAt: 2 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: codeSize.
  gen longAt: 3 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: 6. "stack pointer (framesize=6)"
  gen longAt: 4 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: stackSize
].

gen@(Image Bootstrap Generator traits) generateUtilities
[
  gen generateInstance: #ConsoleObject of: (gen objectNamed: #OddballWindow).

  gen generatePrototype: 'File' &parents: {
    gen objectNamed: #NilObject.
    gen objectNamed: #CloneableTraits.
    gen objectNamed: #DerivableTraits.
    gen objectNamed: #RootTraits
  }.
  gen generatePrototype: 'Directory' &parents: {
    gen objectNamed: #NilObject.
    gen objectNamed: #CloneableTraits.
    gen objectNamed: #DerivableTraits.
    gen objectNamed: #RootTraits
  }.
  gen generatePrototype: 'ExternalLibrary' &parents: {
    gen objectNamed: #NilObject.
    gen objectNamed: #CloneableTraits.
    gen objectNamed: #DerivableTraits.
    gen objectNamed: #RootTraits
  }.
].

gen@(Image Bootstrap Generator traits) generateLobby
[
  gen addObjectNamed: #PrototypesObject valued: (gen cloneOf: (gen objectNamed: #NamespaceProto)).
  (gen objectNamed: #BootstrapObject) addDelegateValued: (gen objectNamed: #PrototypesObject).
  "timmy: no named delegate slots but name needed for accessor"
  (gen objectNamed: #BootstrapObject) makeSlotNamed: #prototypes valued: (gen objectNamed: #PrototypesObject).
  gen addAccessorFor: #prototypes on: (gen objectNamed: #BootstrapObject).
  "Install slots/accessors in the 'prototypes' namespace,
   set up traits traits, and set up printName. Make sure all bootstrapped protos
   are listed here, otherwise these important steps are left out for them."
  [| :slotName :objectName obj window traits |
    obj: (gen objectNamed: objectName).
    (gen objectNamed: #PrototypesObject) makeSlotNamed: slotName valued: obj.
    gen addAccessorFor: slotName on: (gen objectNamed: #PrototypesObject).
    window: obj bmap delegates first.
    window bmap delegates at: 0 put: (gen objectNamed: #CloneableWindow).
    traits: window bmap delegates last"(window getSlot: #traits)".
    traits bmap delegates at: 0 put: (gen objectNamed: #CloneableWindow).
    traits makeSlotNamed: #printName valued: (gen generateLiteral: slotName name ; ' traits').
    gen addAccessorFor: #printName on: traits.
    window makeSlotNamed: #printName valued: (gen generateLiteral: slotName name).
    gen addAccessorFor: #printName on: window.
  ] applier for: #{
    {#Root.             #RootProto}.
    {#Oddball.          #OddballProto}.
    {#Cloneable.        #CloneableProto}.
    {#Derivable.        #DerivableProto}.
    {#Namespace.        #NamespaceProto}.
    {#Boolean.          #BooleanProto}.
    {#Array.            #ArrayProto}.
    {#ByteArray.        #ByteArrayProto}.
    {#ASCIIString.      #ASCIIStringProto}.
    {#ASCIICharacter.   #ASCIICharacterProto}.
    {#Symbol.           #SymbolProto}.
    {#SmallInteger.     #SmallIntegerProto}.
    {#SingleFloat.      #FloatProto}.
    {#Map.              #MapProto}.
    {#LexicalContext.   #LexicalContextProto}.
    {#MethodDefinition. #MethodDefinitionProto}.
    {#Method.           #MethodProto}.
    {#PrimitiveMethod.  #PrimitiveMethodProto}.
    {#CompiledMethod.   #CompiledMethodProto}.
    {#Closure.          #ClosureProto}.
    {#Interpreter.      #InterpreterProto}.
    {#File.             #FileProto}.
    {#Directory.        #DirectoryProto}.
    {#ExternalLibrary.  #ExternalLibraryProto}
  }.

  gen addObjectNamed: #GlobalsObject valued: (gen cloneOf: (gen objectNamed: #NamespaceProto)).
  (gen objectNamed: #BootstrapObject) addDelegateValued: (gen objectNamed: #GlobalsObject).
  (gen objectNamed: #BootstrapObject) makeSlotNamed: #globals valued: (gen objectNamed: #GlobalsObject).
  gen addAccessorFor: #globals on: (gen objectNamed: #BootstrapObject).
  [| :assoc |
   (gen objectNamed: #GlobalsObject) makeSlotNamed: assoc key valued: assoc value.
   gen addAccessorFor: assoc key on: (gen objectNamed: #GlobalsObject)] for: {
    #Console -> (gen objectNamed: #ConsoleObject).
    #NoRole -> (gen objectNamed: #NoRoleObject).
    #Nil -> (gen objectNamed: #NilObject).
    #True -> (gen objectNamed: #TrueObject).
    #False -> (gen objectNamed: #FalseObject).
    #lobby -> (gen objectNamed: #BootstrapObject).
    #bootstrapCharacters -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: gen characters).
    #bootstrapSymbols -> (gen objectNamed: #ArrayProto).
    #bootstrapInterpreter -> (gen objectNamed: #InterpreterObject).
    #ensureMarker -> (gen objectNamed: #EnsureMarkerObject).
    #specialOops -> (gen objectNamed: #ArrayProto).
    #features -> (gen objectNamed: #ArrayProto).
  }.
  gen addMutatorFor: #bootstrapSymbols on: (gen objectNamed: #GlobalsObject).
  gen addMutatorFor: #features on: (gen objectNamed: #GlobalsObject)
].

gen@(Image Bootstrap Generator traits) generateLinkage
"TODO: The order in this method must be the same as in memory.slate, enforce it"
[
  (gen objectNamed: #GlobalsObject) setSlot: #specialOops to:
    (gen cloneOf: (gen objectNamed: #ArrayProto)
      elements:
        {(gen objectNamed: #BootstrapObject).
         (gen objectNamed: #NoRoleObject). (gen objectNamed: #NilObject). (gen objectNamed: #TrueObject). (gen objectNamed: #FalseObject).
         (gen objectNamed: #ArrayProto).
         (gen objectNamed: #ByteArrayProto).
         (gen objectNamed: #ASCIIStringProto).
         (gen objectNamed: #MapProto). (gen objectNamed: #MethodDefinitionProto).
         (gen objectNamed: #SmallIntegerProto). (gen objectNamed: #FloatProto).
         (gen objectNamed: #ClosureWindow). (gen objectNamed: #CompiledMethodWindow). (gen objectNamed: #PrimitiveMethodWindow).
         (gen objectNamed: #ClosureProto). (gen objectNamed: #LexicalContextProto). (gen objectNamed: #InterpreterObject).
         (gen objectNamed: #EnsureMarkerObject).
         gen generateLiteral: #notFoundOn:.
         gen generateLiteral: #notFoundOn:after:.
         gen generateLiteral: #wrongInputsTo:.
         gen generateLiteral: #mayNotReturnTo:.
         gen generateLiteral: #slotNotFoundNamed:.
         gen generateLiteral: #keyNotFoundOn:.
	 gen generateLiteral: #immutable.
         gen generateLiteral: #bitShiftOverflow:.
         gen generateLiteral: #addOverflow:.
         gen generateLiteral: #subtractOverflow:.
         gen generateLiteral: #multiplyOverflow:.
         gen generateLiteral: #divideByZero.
         gen generateLiteral: #notABoolean.
         gen generateLiteral: #applyTo:.
         gen generateLiteral: #&optionals:.
         gen generateLiteral: #badTypeError}).
  (gen objectNamed: #GlobalsObject) setSlot: #bootstrapSymbols to: (gen cloneOf: (gen objectNamed: #ArrayProto) elements: gen symbols valueSet).
].

gen@(Image Bootstrap Generator traits) generatePrimitive: prim at: index
"Given a MethodDefinition representing a Pidgin primitive definition,
this defines a PrimitiveMethod stub that will invoke the given primitive
index. Must be called after generateImageBooting:."
[
  (gen cloneOf: (gen objectNamed: #PrimitiveMethodProto)) `>>
   [setSlots: {
      #selector -> (gen generateLiteral: prim selector).
      #inputVariables -> prim roles size.
      #index -> index
    }.
    addMethodNamed: prim selector
      on: (prim roles collect:
	[| :role |
         (role isSameAs: Syntax UnaryMessage)
           ifTrue:
             [inform: ' Adding primitive %s to %s', index, role selector.
              gen objectNamed: role selector]]) ]
].

gen@(Image Bootstrap Generator traits) generateLiteral: literal
[
  literal == NoRole
    ifTrue: [gen objectNamed: #NoRoleObject]
    ifFalse: [error: 'Unsupported literal.']
].

gen@(Image Bootstrap Generator traits) generateLiteral: i@(SmallInteger traits)
[i].

gen@(Image Bootstrap Generator traits) generateLiteral: _@(BigInteger traits)
[
  error: 'The bootstrap generator does not support big integers.'
].

gen@(Image Bootstrap Generator traits) generateLiteral: _@True
[gen objectNamed: #TrueObject].

gen@(Image Bootstrap Generator traits) generateLiteral: _@False
[gen objectNamed: #FalseObject].

gen@(Image Bootstrap Generator traits) generateLiteral: _@Nil
[gen objectNamed: #NilObject].

gen@(Image Bootstrap Generator traits) generateLiteral: _@lobby
[gen objectNamed: #BootstrapObject].

gen@(Image Bootstrap Generator traits) generateLiteral: s@(ASCIIString traits)
[
  s isEmpty
    ifTrue: [gen objectNamed: #ASCIIStringProto]
    ifFalse: [gen cloneOf: (gen objectNamed: #ASCIIStringProto) elements: (s collect: #code`er into: (ByteArray newSizeOf: s))]
].

gen@(Image Bootstrap Generator traits) generateLiteral: s@(Symbol traits)
[
  gen symbols
    at: s
    ifAbsentPut:
      [gen cloneOf: (gen objectNamed: #SymbolProto) elements: (s name collect: #code`er into: (ByteArray newSizeOf: s name))]
].

gen@(Image Bootstrap Generator traits) generateLiteral: f@(SingleFloat traits)
[| obj |
  obj := (gen cloneOf: (gen objectNamed: #FloatProto) elements: (ByteArray newWithAll: f)).
  gen littleEndian = -1.0 isLittleEndian
    ifFalse: [obj elements := obj elements reversed].
  obj
].

gen@(Image Bootstrap Generator traits) generateLiteral: a@(ByteArray traits)
[
  a isEmpty
    ifTrue: [gen objectNamed: #ByteArrayProto]
    ifFalse: [gen cloneOf: (gen objectNamed: #ByteArrayProto) elements: a]
].

gen@(Image Bootstrap Generator traits) generateLiteral: a@(Array traits)
[
  a isEmpty
    ifTrue: [gen objectNamed: #ArrayProto]
    ifFalse: [gen cloneOf: (gen objectNamed: #ArrayProto) elements: (a collect: [| :each | gen generateLiteral: each])]
].

gen@(Image Bootstrap Generator traits) generateLiteral: c@(ASCIIString Character traits)
[
  gen characters at: c code
].

gen@(Image Bootstrap Generator traits) generateLiteral: block@(CompiledMethod traits)
[| obj |
  obj := (gen cloneOf: (gen objectNamed: #CompiledMethodProto)) `>>
   [setSlots: {
      #inputVariables -> block inputVariables.
      #localVariables -> block localVariables.
      #restVariable -> (gen generateLiteral: block restVariable).
      #heapAllocate -> (gen generateLiteral: block heapAllocate).
      #literals -> (gen generateLiteral: block literals).
      #registerCount -> (gen generateLiteral: block registerCount).
      #selectors -> (gen generateLiteral: block selectors).
      #code -> (gen generateLiteral: block code)}. ].
  obj setSlot: #method to: obj.
  block optionalKeywords isEmpty
    ifFalse:
      [obj setSlot: #optionalKeywords to: (gen generateLiteral: block optionalKeywords)].
  obj
].
