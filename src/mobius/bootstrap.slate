"fixme: this is overwritten everytime you make a new generator"
define: #BytesPerWord -> 4.
"The size of a word in bytes on the target platform."
"TODO: Make this an attribute of an accessible target description."

define: #Chunk &slots: {#oop}.

_@(Chunk traits) wordSize [overrideThis].

define: #SlotEntry &slots: {#name. #offset}.

se@(SlotEntry traits) newNamed: name offset: offset
[se clone `>> [name := name. offset := offset. ]].

define: #RoleEntry &slots:
  {#name. #rolePositions -> 0. #methodDefinition}.

re@(RoleEntry traits) newNamed: name rolePositions: positions methodDefinition: method
[re clone `>>
   [name := name. rolePositions := positions. methodDefinition := method. ]].

define: #MethodDefinition &slots:
  {#dispatchPositions -> 0. #method. #slotAccessor}.

md@(MethodDefinition traits) newDispatchPositions: positions method: method
[md clone `>> [dispatchPositions := positions. method := method. ]].

define: #Map &slots:
  {#flags -> 0. #representative -> Nil.
   #delegates -> {}.
   #slotCount -> 0.
   #slotTable -> {}.
   #roleTable -> {}}.

map@(Map traits) addSlotNamed: name at: offset
[
  map slotTable infect: #clone `er.
  map slotTable := map slotTable copyWith:
    (map surroundings SlotEntry newNamed: name offset: offset).
].

map@(Map traits) addRoleNamed: name at: position dispatching: def
[
  map roleTable
    doWithIndex:
      [| :role :index |
       role methodDefinition == def
         ifTrue:
           [(map roleTable := map roleTable copy) at: index :=
              (map surroundings RoleEntry
                 newNamed: name
                 rolePositions: (role rolePositions bitOr: (1 bitShift: position))
                 methodDefinition: def).
            ^ False]].
  map roleTable :=
    map roleTable copyWith:
      (map surroundings RoleEntry
         newNamed: name
         rolePositions: (1 bitShift: position)
         methodDefinition: def).
  True
].

define: #Object &parents: {Chunk} &slots:
  {#idHash. #bmap -> Map. #slotValues -> {}}.

_@(Object traits) headerWords
[4].

obj@(Object traits) wordSizeSansPayload
[obj headerWords + obj slotValues size].

obj@(Object traits) wordSize
[obj wordSizeSansPayload].

obj@(Object traits) makeSlotNamed: name valued: value
[| index |
  index := obj bmap slotCount.
  obj bmap := obj bmap clone `>>
    [slotCount := index + 1.
     addSlotNamed: name at: obj headerWords + index * obj surroundings BytesPerWord. ].
  obj slotValues := obj slotValues copyWith: value.
  obj
].

obj@(Object traits) setSlot: name to: val
[
  obj bmap slotTable
    do: [| :slot | slot name = name ifTrue:
      [^ (obj slotValues at: slot offset / obj surroundings BytesPerWord - obj headerWords put: val)]].
  error: 'Slot missing: ' ; name
].

obj@(Object traits) setSlots: namesAndValues
[
  namesAndValues do: [| :assoc | obj setSlot: assoc key to: assoc value]
].

obj@(Object traits) getSlot: name
[
  obj bmap slotTable
    do: [| :slot | slot name = name ifTrue:
      [^ (obj slotValues at: slot offset / obj surroundings BytesPerWord - obj headerWords)]].
  error: 'Slot missing: ' ; name
].

obj@(Object traits) addDelegateValued: value
[
  obj bmap := obj bmap clone `>>
    [delegates := obj bmap delegates copyWith: value. ].
  obj
].

obj@(Object traits) addRoleNamed: name at: position dispatching: def
[
  obj bmap addRoleNamed: name at: position dispatching: def
].

method@(Object traits) addMethodNamed: name on: roles
[| def |
  def := method surroundings MethodDefinition newDispatchPositions: 0 method: method.
  roles doWithIndex:
    [| :role :index |
      role ifNotNil:
        [def dispatchPositions := def dispatchPositions bitOr: (1 bitShift: index).
         role addRoleNamed: name at: index dispatching: def]].
  "inform: 'Adding method %r roles: %r pos: %r', name, roles, def dispatchPositions."
  def
].

define: #Array &parents: {Object}.

define: #OopArray &parents: {Array}
  &slots: {#elements -> {}}.

arr@(OopArray traits) wordSize
[arr wordSizeSansPayload + arr elements size].

define: #ByteArray &parents: {Array}
  &slots: {#elements -> imports ByteArray new}.

arr@(ByteArray traits) byteSize
[
  arr wordSizeSansPayload * arr surroundings BytesPerWord + arr elements size
].

arr@(ByteArray traits) wordSize
[
  arr wordSizeSansPayload + (arr elements size + arr surroundings BytesPerWord - 1 // arr surroundings BytesPerWord)
].

define: #CompiledMethod &parents: {Object}.

define: #Generator &slots: {
  #translations -> IdentityDictionary new.
  #chunks -> ExtensibleArray new.
  #characters -> ({} newSizeOf: imports ASCIIString Character CharacterSet).
  #symbols -> Dictionary new.
  #littleEndian -> True.
  #bytesPerWord -> BytesPerWord.
  #nextHash -> 0.
  #imageSize -> 0.
  #objects -> Dictionary new.
}.

gen@(Generator traits) new &littleEndian: littleEndian &wordSize: wordSize
[
  littleEndian `defaultsTo: gen littleEndian.
  wordSize `defaultsTo: Platform Current bytesPerWord * 8.
  define: #BytesPerWord -> (wordSize // 8).
  gen clone `setting:
    #{#objects. #translations. #chunks. #characters. #symbols. #bytesPerWord. #littleEndian}
    to: {gen objects new.
	 gen translations new.
	 gen chunks new.
	 gen characters copy.
	 gen symbols new.
         wordSize // 8.
	 littleEndian}
].

gen@(Generator traits) generateImageBooting: method withPrims: prims
"Generates the primary image objects such that the supplied CompiledMethod
will be interpreted immediately upon loading the image."
[
  inform: 'Generating kernel'.
  gen generateKernel.
  inform: 'Generating utilities'.
  gen generateUtilities.
  inform: 'Generating kernel accessors'.
  gen generateKernelAccessors.
  inform: 'Generating interpreter'.
  gen generateInterpreterBooting: method.
  inform: 'Generating lobby'.
  gen generateLobby.
  inform: 'Generating prims'.
  prims do: [| :assoc | gen generatePrimitive: assoc value at: assoc key].
  inform: 'Generating maps'.
  gen generateMaps.
  inform: 'Generating linkage'.
  gen generateLinkage
].

gen@(Generator traits) objectNamed: name
[gen objects at: name].

gen@(Generator traits) bytesAt: i in: arr put: val numBytes: bytes
[
  0 below: bytes do:
    [| :index |
     arr elements at: i + index put:
       (val byteShift: (gen littleEndian ifTrue: [0 - index]
                                         ifFalse: [0 - bytes + index])) intoByte]
].

gen@(Generator traits) shortAt: i in: arr put: val
[
  gen bytesAt: i in: arr put: val numBytes: gen bytesPerWord // 2
].

gen@(Generator traits) longAt: i in: arr put: val
[
  gen bytesAt: i in: arr put: val numBytes: gen bytesPerWord
].

gen@(Generator traits) capacityForTable: table
[
  (table size * 5 // 4) leastGreaterPowerOfTwo
].

gen@(Generator traits) generateSlotTableFor: map
[| obj capacity selector hash |
  capacity := gen capacityForTable: map slotTable.
  obj := gen cloneOf: (gen objectNamed: #ArrayProto) sized: 2 * capacity.
  map slotTable do:
    [| :se |
     selector := gen generateLiteral: se name.
     hash := (selector idHash bitAnd: capacity - 1) * 2.
     [(obj elements at: hash) isNil]
       whileFalse:
         [hash := (hash + 2) \\ (capacity * 2)].
     obj elements at: hash put: selector.
     obj elements at: hash + 1 put: se offset].
  obj
].

gen@(Generator traits) generateRoleTableFor: map
[| obj capacity selector hash insert |
  capacity := gen capacityForTable: map roleTable.
  obj := gen cloneOf: (gen objectNamed: #ArrayProto) sized: 4 * capacity.
  map roleTable do:
    [| :re |
     selector := gen generateLiteral: re name.
     hash := (selector idHash bitAnd: capacity - 1) * 4.
     [(obj elements at: hash) isNil
        \/ [(obj elements at: hash) == selector]]
       whileFalse:
         [hash := (hash + 4) \\ (capacity * 4)].
     insert := hash.
     [(obj elements at: insert) isNil]
       whileFalse:
         [insert := (insert + 4) \\ (capacity * 4)].
     obj elements at: insert put: selector.
     obj elements at: insert + 1 put: re rolePositions.
     obj elements at: insert + 2 put: (gen generateMethodDef: re methodDefinition).
     insert == hash
       ifFalse:
         [[(obj elements at: hash + 3) isNil]
            whileFalse: [hash := (obj elements at: hash + 3) * 4].
          obj elements at: hash + 3 put: insert // 4]].
  obj
].

gen@(Generator traits) generateMethodDef: def
[
  gen translations at: def
    ifAbsentPut:
      [| obj sym |
       (sym := def method getSlot: #selector)
         setSlot: #cacheMask to: ((sym getSlot: #cacheMask) bitOr: def dispatchPositions).
       (obj := gen cloneOf: (gen objectNamed: #MethodDefinitionProto)) setSlots: {
         #method -> def method.
         #slotAccessor -> (gen generateLiteral: def slotAccessor)
       }.
       gen longAt: 1 * gen bytesPerWord in: obj put: def dispatchPositions.
       obj]
].

gen@(Generator traits) generateMap: map
[
  gen translations at: map
    ifAbsentPut:
      [(gen cloneOf: (gen objectNamed: #MapProto)) `>>
         [setSlots: {#flags -> map flags.
                     #representative -> (map representative ifNil: [gen objectNamed: #NilObject]).
                     #delegates -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: map delegates).
                     #slotCount -> map slotCount.
                     #slotTable -> (gen generateSlotTableFor: map).
                     #roleTable -> (gen generateRoleTableFor: map)}. ]]
].

gen@(Generator traits) generateMaps
[
  gen objects keysAndValuesDo:
    [| :name :obj |
     inform: ' Adding map for %s', name.
     gen generateMap: obj bmap]
].

obj@(Object traits) nextOop
"Answer the pointer to just beyond this object."
[obj oop + (obj wordSize * obj surroundings BytesPerWord)].

gen@(Generator traits) assignOops
"Assign oops to all of the chunks, accumulating the final oop which is used
to set the image size."
[
  gen imageSize := gen chunks inject: 0 into:
    [| :oop :chunk | chunk oop := oop. chunk nextOop]
].

gen@(Generator traits) emitInteger: val on: stream byteSize: byteSize
"Takes an integer and outputs the binary data value in the correct byte-order
onto the stream."
[
  stream next: byteSize putInteger: val &littleEndian: gen littleEndian
].

gen@(Generator traits) emitLong: val on: stream
"Takes an integer and outputs the binary data value in the correct byte-order
onto the stream."
[
  gen emitInteger: val on: stream byteSize: gen bytesPerWord
].

gen@(Generator traits) emitOopOf: chunk on: stream
[gen emitLong: chunk oop on: stream].

gen@(Generator traits) emitOopOf: _@Nil on: stream
[gen emitOopOf: (gen objectNamed: #NilObject) on: stream].

gen@(Generator traits) emitOopOf: i@(imports SmallInteger traits) on: stream
[gen emitLong: (i << 1 bitOr: 1) on: stream].

gen@(Generator traits) emitObjectHashed: hash sized: size payload: payload format: format on: stream
[
  "fix: check big endian"
  "header"
  gen littleEndian ifFalse:
    [gen emitInteger: 0 on: stream byteSize: gen bytesPerWord - 4].
  stream nextPutAll:
    ((gen littleEndian
      ifTrue:
        [{2r1 bitOr: (hash bitAnd: 16r7F) << 1.
          (hash >> 7) intoByte.
          (hash >> 15) intoByte.
          format << 6}]
      ifFalse:
        [{2r10000000 bitOr: (hash >> 16 bitAnd: 16r7F).
          (hash >> 8) intoByte.
          hash intoByte.
          format}]) as: ByteArray).
  gen littleEndian ifTrue:
    [gen emitInteger: 0 on: stream byteSize: gen bytesPerWord - 4].

  "size in words of slot data"
  gen emitLong: size on: stream.
  "size in bytes of payload (oop array or byte array)"
  gen emitLong: payload on: stream.  

  stream
].

gen@(Generator traits) emit: obj@(Object traits) on: stream
[
  gen emitObjectHashed: obj idHash sized: obj wordSize payload: 0 format: 2r00 on: stream.
  gen emitLong: (gen translations at: obj bmap) oop on: stream.
  obj slotValues
    do: [| :slotVal | gen emitOopOf: slotVal on: stream].
  obj
].

gen@(Generator traits) emit: obj@(OopArray traits) on: stream
[
  gen emitObjectHashed: obj idHash
    sized: obj wordSizeSansPayload
    payload: obj elements size * gen bytesPerWord
    format: 2r01
    on: stream.
  gen emitLong: (gen translations at: obj bmap) oop on: stream.
  (obj slotValues ;; obj elements)
    do: [| :slotVal | gen emitOopOf: slotVal on: stream].
  obj
].

gen@(Generator traits) emit: obj@(ByteArray traits) on: stream
[
  gen emitObjectHashed: obj idHash
    sized: obj wordSizeSansPayload
    payload: obj elements size
    format: 2r10
    on: stream.
  gen emitLong: (gen translations at: obj bmap) oop on: stream.
  obj slotValues do: [| :slotVal | gen emitOopOf: slotVal on: stream].
  stream nextPutAll: obj elements.
  stream next: (gen bytesPerWord - obj elements size) \\ gen bytesPerWord put: 0.
  obj
].

gen@(Generator traits) emitHeaderOn: stream
[
  gen emitLong: 16rABCDEF43 on: stream.
  gen emitLong: gen imageSize on: stream.
  gen emitLong: gen nextHash on: stream.
  gen emitLong: ((gen objectNamed: #GlobalsObject) getSlot: #specialOops) oop on: stream.
"i shortened dispatch id to one word"
  gen emitLong: 0 on: stream.
].

gen@(Generator traits) emitOn: stream
"Emits a bootstrap image on the stream after it has been generated."
[
  inform: 'Assigning oops'.
  gen assignOops.
  inform: 'Emitting image: %s', stream resource locator.
  gen emitHeaderOn: stream.
  gen chunks do: [| :chunk | gen emit: chunk on: stream]
].

gen@(Generator traits) addObjectNamed: name valued: obj
[
  inform: ' Adding object %s', name.
  gen objects at: name put: obj.
  obj
].

gen@(Generator traits) newIdentityHash
[| hash |
  hash := gen nextHash.
  gen nextHash += 1.
  hash
].

gen@(Generator traits) new: layout fromMap: map
[| obj |
  obj := layout clone `>> [idHash := gen newIdentityHash. bmap := map. ].
  obj slotValues := obj slotValues newSize: map slotCount.
  map representative := obj.
  gen chunks addLast: obj.
  obj
].

gen@(Generator traits) newMap
[
  gen surroundings Map clone
].

gen@(Generator traits) newObject
[
  gen new: gen surroundings Object
].

gen@(Generator traits) new: layout
[
  gen new: layout fromMap: gen newMap
].

gen@(Generator traits) cloneOf: proto@(Object traits)
[
  gen chunks addLast: proto clone `>>
    [idHash := gen newIdentityHash. slotValues := proto slotValues copy. ]
].

gen@(Generator traits) cloneOf: arr@(Array traits)
[resend `>> [elements := arr elements copy. ]].

gen@(Generator traits) cloneOf: proto sized: size
[(gen cloneOf: proto) `>> [elements := proto elements newSize: size. ]].

gen@(Generator traits) cloneOf: proto elements: elements
[(gen cloneOf: proto) `>> [elements := elements as: proto elements. ]].

gen@(Generator traits) addAccessorFor: slotName on: obj
[| accessor selector |
  selector := obj accessorNameFor: slotName.
  accessor := gen cloneOf: (gen objectNamed: #CompiledMethodProto).
  accessor setSlots: {
    #method -> accessor.
    #selector -> (gen generateLiteral: selector).
    #inputVariables -> 1.
    #localVariables -> 1.
    #registerCount -> 3.
    #literals -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: slotName}).
    #selectors -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: #atSlotNamed:}).
    #code ->
    (gen cloneOf: (gen objectNamed: #ArrayProto)
      elements: {
        VM SSACode loadVariable. 0.
        VM SSACode loadLiteral. 1. gen generateLiteral: slotName.
        VM SSACode directSendMessage. 0. gen generateLiteral: #atSlotNamed:. 2. 0. 1.
        VM SSACode returnRegister. 0
      })
  }.
  (accessor addMethodNamed: selector on: {obj}) slotAccessor: slotName.
  accessor
].

gen@(Generator traits) addMutatorFor: slotName on: obj
[| mutator selector |
  mutator := gen cloneOf: (gen objectNamed: #CompiledMethodProto).
  selector := obj mutatorNameFor: slotName.
  mutator setSlots: {
    #method -> mutator.
    #selector -> (gen generateLiteral: selector).
    #inputVariables -> 2.
    #localVariables -> 1.
    #registerCount -> 4.
    #literals -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: slotName}).
    #selectors -> (gen cloneOf: (gen objectNamed: #ArrayProto) elements: {gen generateLiteral: #atSlotNamed:put:}).
    #code ->
    (gen cloneOf: (gen objectNamed: #ArrayProto)
      elements:
        {
          VM SSACode loadVariable. 0.
          VM SSACode loadVariable. 1.
          VM SSACode loadLiteral. 2. gen generateLiteral: slotName.
          VM SSACode directSendMessage. 0. gen generateLiteral: #atSlotNamed:put:. 3. 0. 2. 1.
          VM SSACode returnRegister. 0
        })
  }.
  (mutator addMethodNamed: selector on: {obj. Nil}) slotAccessor: slotName.
  mutator
].

gen@(Generator traits) addAccessorsFor: slotName on: obj
[
  gen addAccessorFor: slotName on: obj.
  gen addMutatorFor: slotName on: obj
].

gen@(Generator traits) generateKernelAccessors
[
  gen objects do:
    [| :obj |
     obj bmap slotTable do: [| :slot | gen addAccessorsFor: slot name on: obj]]
].

gen@(Generator traits) generatePrototype: name &suffix: suffix &layout: layout &parents: parents &slots: slotSpecs &elements: elements
[| traits window result |
  suffix `defaultsTo: 'Proto'.
  traits := (gen addObjectNamed: (name ; 'Traits') intern valued: gen newObject)
    `>> [addDelegateValued: Nil. ].
  window := (gen addObjectNamed: (name ; 'Window') intern valued: gen newObject)
    `>> [bmap flags := 1. addDelegateValued: Nil. ].
  parents
    ifNotNil:
      [parents reverseDoWithIndex:
        [| :parent :index |
          window addDelegateValued: parent]].
  window addDelegateValued: traits.
  result := (gen addObjectNamed: (name ; suffix) intern
	       valued: (layout ifNil: [gen newObject] ifNotNil: [gen new: layout]))
    `>> [addDelegateValued: window. ].
  elements ifNotNil:
    [(result hasSlotNamed: #elements) ifTrue: [result elements := elements]].
  (slotSpecs `defaultsTo: {}) do:
    [| :spec | result makeSlotNamed: spec key valued: spec value].
  result
].

gen@(Generator traits) generateInstance: name of: window
[(gen addObjectNamed: name valued: gen newObject) `>>
  [addDelegateValued: window.]
].

gen@(Generator traits) generateKernel
[
  gen generatePrototype: 'Root'.
  gen generatePrototype: 'Oddball' &parents: {gen objectNamed: #RootTraits}.
  gen generatePrototype: 'Derivable' &parents: {gen objectNamed: #RootTraits}.
  gen generatePrototype: 'Cloneable' &parents: {gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.

  gen generateInstance: #NilObject of: (gen objectNamed: #OddballWindow).
  gen generateInstance: #NoRoleObject of: (gen objectNamed: #OddballWindow).

  gen generatePrototype: 'Boolean' &parents: {gen objectNamed: #OddballTraits. gen objectNamed: #RootTraits}.
  gen generateInstance: #TrueObject of: (gen objectNamed: #BooleanWindow).
  gen generateInstance: #FalseObject of: (gen objectNamed: #BooleanWindow).

  gen generatePrototype: 'Array' &layout: gen surroundings OopArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &elements: Array new.
  gen generatePrototype: 'ByteArray' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &elements: ByteArray new.

  gen generatePrototype: 'SmallInteger' &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #OddballTraits. gen objectNamed: #RootTraits}.
  (gen generatePrototype: 'Float' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #ByteArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}) `>>
    [elements: (ByteArray newSize: gen bytesPerWord)].

  gen generatePrototype: 'ASCIIString' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #ByteArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.

  gen generatePrototype: 'Symbol' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #ASCIIStringTraits. gen objectNamed: #NilObject. gen objectNamed: #ByteArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#cacheMask -> 0}.

  gen symbols at: #'' put: (gen objectNamed: #SymbolProto).

  gen generatePrototype: 'ASCIICharacter'
    &parents: {gen objectNamed: #NilObject. gen objectNamed: #OddballTraits. gen objectNamed: #RootTraits} &slots: {#code -> 0}.
  gen characters at: 0 put: (gen objectNamed: #ASCIICharacterProto).
  1 below: gen characters size
    do: [| :index c |
      c: (gen cloneOf: (gen objectNamed: #ASCIICharacterProto)).
      c setSlot: #code to: index.
      gen characters at: index put: c].
  (gen objectNamed: #ASCIIStringTraits) makeSlotNamed: #Character valued: (gen objectNamed: #ASCIICharacterProto).

  gen generatePrototype: 'Namespace'
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.
  gen generateInstance: #BootstrapObject of: (gen objectNamed: #NamespaceWindow).

  gen generatePrototype: 'Method' &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}.

  gen generatePrototype: 'PrimitiveMethod'
    &parents: {gen objectNamed: #MethodTraits. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#index -> 0. #selector -> (gen objectNamed: #NilObject). #inputVariables -> 0}.

  gen generatePrototype: 'CompiledMethod'
    &parents: {gen objectNamed: #MethodTraits. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#method -> (gen objectNamed: #NilObject). #selector -> (gen objectNamed: #NilObject).
	#inputVariables -> 0. #localVariables -> 0.
	#restVariable -> (gen objectNamed: #FalseObject).
	#optionalKeywords -> (gen objectNamed: #ArrayProto).
	#heapAllocate -> (gen objectNamed: #FalseObject).
	#environment -> (gen objectNamed: #BootstrapObject).
	#literals -> (gen objectNamed: #ArrayProto).
	#selectors -> (gen objectNamed: #ArrayProto).
	#code -> (gen objectNamed: #ArrayProto).
	#sourceTree -> (gen objectNamed: #NilObject).
	#debugMap -> (gen objectNamed: #ArrayProto).
        #isInlined -> (gen objectNamed: #FalseObject).
        #oldCode -> (gen objectNamed: #NilObject).
        #callCount -> 0.
        #calleeCount -> (gen objectNamed: #NilObject).
        #registerCount -> 0.
        #cachedInCallers -> (gen objectNamed: #NilObject).
        #cachedInCallersCount -> 0.
        #nextInlineAtCallCount -> (gen objectNamed: #NilObject).
        #reserved5 -> (gen objectNamed: #NilObject).
        #reserved6 -> 0}.

  gen generatePrototype: 'Closure' &layout: gen surroundings OopArray
    &parents: {gen objectNamed: #MethodTraits. gen objectNamed: #ArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#method -> (gen objectNamed: #NilObject)}.

  gen generatePrototype: 'MethodDefinition' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#method -> (gen objectNamed: #CompiledMethodProto). #slotAccessor -> (gen objectNamed: #NilObject)}
    &elements: (ByteArray newSize: 4 * gen bytesPerWord).

  gen generatePrototype: 'Map' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#flags -> 0. #representative -> (gen objectNamed: #NilObject).
     #delegates -> (gen objectNamed: #ArrayProto). #slotCount -> 0.
     #slotTable -> (gen objectNamed: #ArrayProto). #roleTable -> (gen objectNamed: #ArrayProto)}
    &elements: (ByteArray newSize: 3 * gen bytesPerWord).

  gen generatePrototype: 'LexicalContext' &layout: gen surroundings OopArray
    &parents: {gen objectNamed: #ArrayTraits. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #NilObject. gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#framePointer -> 0}.

  gen generatePrototype: 'Interpreter' &layout: gen surroundings ByteArray
    &parents: {gen objectNamed: #CloneableTraits. gen objectNamed: #DerivableTraits. gen objectNamed: #RootTraits}
    &slots: {#stack -> (gen objectNamed: #ArrayProto).
     #method -> (gen objectNamed: #NilObject).
     #closure -> (gen objectNamed: #NilObject).
     #lexicalContext -> (gen objectNamed: #NilObject).
     #ensureHandlers -> 0}
    &elements: (ByteArray newSize: 5 * gen bytesPerWord).

  (gen addObjectNamed: #EnsureMarkerObject valued: (gen cloneOf: (gen objectNamed: #CompiledMethodProto))) `>>
    [| :marker |
      setSlot: #method to: marker.
      setSlot: #code to:
        (gen cloneOf: (gen objectNamed: #ArrayProto)
          elements: {VM SSACode resume})].
].

gen@(Generator traits) generateInterpreterBooting: method
[| compiler stackObj stackSize methodObj codeSize |
  compiler := VM SSACompiler new.
  _@compiler branchTableHash: key
  [| literal |
    literal := gen generateLiteral: key.
    (literal isSameAs: SmallInteger)
      ifTrue: [literal]
      ifFalse: [literal idHash]
  ].
  inform: 'Compiling the syntax tree of bootstrap code and libraries into SSA code.'.
  
  method := (compiler generate: method result: Nil &topLevel: True) `>> [heapAllocate := False. ].

  "compiler decompile: method code."

  methodObj := gen generateLiteral: method.

  stackSize := 16. "if you change this, change vm.c which has it hard-coded in the beginning of interpret()"

  stackObj := (gen cloneOf: (gen objectNamed: #ArrayProto) sized: stackSize) `>>
    [elements at: 0 put: 0. "-6: prev sp"
     elements at: 1 put: -1. "-5: resultStackPointer"
     elements at: 2 put: 0. "-4: code pointer"
     elements at: 3 put: methodObj. "-3: closure"
     elements at: 4 put: 0. "-2: lexical context"
     elements at: 5 put: 0. "-1: prev fp"
     elements at: 6 put: 0. ].

  codeSize := method code size.

  gen addObjectNamed: #InterpreterObject valued: (gen cloneOf: (gen objectNamed: #InterpreterProto)).
  (gen objectNamed: #InterpreterObject) setSlots: {
    #stack -> stackObj.
    #method -> methodObj.
    #closure -> methodObj
  }.
  gen longAt: 0 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: 6. " frame pointer (framesize=6)"
  "long at 1 is code pointer -- I guess this gets filled later or is zero"
  gen longAt: 2 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: codeSize.
  gen longAt: 3 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: 6. "stack pointer (framesize=6)"
  gen longAt: 4 * gen bytesPerWord in: (gen objectNamed: #InterpreterObject) put: stackSize
].

gen@(Generator traits) generateUtilities
[
  gen generateInstance: #ConsoleObject of: (gen objectNamed: #OddballWindow).

  gen generatePrototype: 'File' &parents: {
    gen objectNamed: #NilObject.
    gen objectNamed: #CloneableTraits.
    gen objectNamed: #DerivableTraits.
    gen objectNamed: #RootTraits
  }.
  gen generatePrototype: 'Directory' &parents: {
    gen objectNamed: #NilObject.
    gen objectNamed: #CloneableTraits.
    gen objectNamed: #DerivableTraits.
    gen objectNamed: #RootTraits
  }.
  gen generatePrototype: 'ExternalLibrary' &parents: {
    gen objectNamed: #NilObject.
    gen objectNamed: #CloneableTraits.
    gen objectNamed: #DerivableTraits.
    gen objectNamed: #RootTraits
  }.
].

gen@(Generator traits) generateLobby
[
  gen addObjectNamed: #PrototypesObject valued: (gen cloneOf: (gen objectNamed: #NamespaceProto)).
  (gen objectNamed: #BootstrapObject) addDelegateValued: (gen objectNamed: #PrototypesObject).
  "timmy: no named delegate slots but name needed for accessor"
  (gen objectNamed: #BootstrapObject) makeSlotNamed: #prototypes valued: (gen objectNamed: #PrototypesObject).
  gen addAccessorFor: #prototypes on: (gen objectNamed: #BootstrapObject).
  "Install slots/accessors in the 'prototypes' namespace,
   set up traits traits, and set up printName. Make sure all bootstrapped protos
   are listed here, otherwise these important steps are left out for them."
  [| :slotName :objectName obj printNameLiteral window traits |
    obj := gen objectNamed: objectName.
    (gen objectNamed: #PrototypesObject) makeSlotNamed: slotName valued: obj.
    gen addAccessorFor: slotName on: (gen objectNamed: #PrototypesObject).
    window := obj bmap delegates first.
    window bmap delegates at: 0 put: (gen objectNamed: #CloneableWindow).
    traits := window bmap delegates last"(window getSlot: #traits)".
    traits bmap delegates at: 0 put: (gen objectNamed: #CloneableWindow).
    printNameLiteral := gen generateLiteral: slotName name.
    traits makeSlotNamed: #printNameTraits valued: printNameLiteral.
    gen addAccessorFor: #printNameTraits on: traits.
    window makeSlotNamed: #printNameWindow valued: printNameLiteral.
    gen addAccessorFor: #printNameWindow on: window
  ] applier for: #{
    {#Root.             #RootProto}.
    {#Oddball.          #OddballProto}.
    {#Cloneable.        #CloneableProto}.
    {#Derivable.        #DerivableProto}.
    {#Namespace.        #NamespaceProto}.
    {#Boolean.          #BooleanProto}.
    {#Array.            #ArrayProto}.
    {#ByteArray.        #ByteArrayProto}.
    {#ASCIIString.      #ASCIIStringProto}.
    {#ASCIICharacter.   #ASCIICharacterProto}.
    {#Symbol.           #SymbolProto}.
    {#SmallInteger.     #SmallIntegerProto}.
    {#SingleFloat.      #FloatProto}.
    {#Map.              #MapProto}.
    {#LexicalContext.   #LexicalContextProto}.
    {#MethodDefinition. #MethodDefinitionProto}.
    {#Method.           #MethodProto}.
    {#PrimitiveMethod.  #PrimitiveMethodProto}.
    {#CompiledMethod.   #CompiledMethodProto}.
    {#Closure.          #ClosureProto}.
    {#Interpreter.      #InterpreterProto}.
    {#File.             #FileProto}.
    {#Directory.        #DirectoryProto}.
    {#ExternalLibrary.  #ExternalLibraryProto}
  }.

  gen addObjectNamed: #GlobalsObject valued: (gen cloneOf: (gen objectNamed: #NamespaceProto)).
  (gen objectNamed: #BootstrapObject) addDelegateValued: (gen objectNamed: #GlobalsObject).
  (gen objectNamed: #BootstrapObject) makeSlotNamed: #globals valued: (gen objectNamed: #GlobalsObject).
  gen addAccessorFor: #globals on: (gen objectNamed: #BootstrapObject).
  [| :key :value |
   (gen objectNamed: #GlobalsObject) makeSlotNamed: key valued: value.
   gen addAccessorFor: key on: (gen objectNamed: #GlobalsObject)] applier for: {
     {#Console.              gen objectNamed: #ConsoleObject}.
     {#NoRole.               gen objectNamed: #NoRoleObject}.
     {#Nil.                  gen objectNamed: #NilObject}.
     {#True.                 gen objectNamed: #TrueObject}.
     {#False.                gen objectNamed: #FalseObject}.
     {#lobby.                gen objectNamed: #BootstrapObject}.
     {#bootstrapCharacters.  gen cloneOf: (gen objectNamed: #ArrayProto) elements: gen characters}.
     {#bootstrapSymbols.     gen objectNamed: #ArrayProto}.
     {#Symbols.              gen objectNamed: #NilObject}.
     {#bootstrapInterpreter. gen objectNamed: #InterpreterObject}.
     {#ensureMarker.         gen objectNamed: #EnsureMarkerObject}.
     {#specialOops.          gen objectNamed: #ArrayProto}.
     {#features.             gen objectNamed: #ArrayProto}.
  }.
  gen addMutatorFor: #bootstrapSymbols on: (gen objectNamed: #GlobalsObject).
  gen addMutatorFor: #features on: (gen objectNamed: #GlobalsObject)
].

gen@(Generator traits) generateLinkage
"TODO: The order in this method must be the same as in memory.slate, enforce it"
[
  (gen objectNamed: #GlobalsObject) setSlot: #specialOops to:
    (gen cloneOf: (gen objectNamed: #ArrayProto) elements:
       (#{#BootstrapObject.
          #NoRoleObject.
          #NilObject.
          #TrueObject.
          #FalseObject.
          #ArrayProto.
          #ByteArrayProto.
          #ASCIIStringProto.
          #MapProto.
          #MethodDefinitionProto.
          #SmallIntegerProto.
          #FloatProto.
          #ClosureWindow.
          #CompiledMethodWindow.
          #PrimitiveMethodWindow.
          #ClosureProto.
          #LexicalContextProto.
          #InterpreterObject.
          #EnsureMarkerObject.
      } collect: #(gen objectNamed: _) `er)
       ; ({#notFoundOn:.
           #notFoundOn:after:.
           #wrongInputsTo:.
           #mayNotReturnTo:.
           #slotNotFoundNamed:.
           #keyNotFoundOn:.
	   #immutable.
           #bitShiftOverflow:.
           #addOverflow:.
           #subtractOverflow:.
           #multiplyOverflow:.
           #divideByZero.
           #notABoolean.
           #applyTo:.
           #&optionals:.
           #badTypeError} collect: #(gen generateLiteral: _) `er)).
  (gen objectNamed: #GlobalsObject) setSlot: #bootstrapSymbols to:
    (gen cloneOf: (gen objectNamed: #ArrayProto) elements: gen symbols valueSet).
].

gen@(Generator traits) generatePrimitive: prim at: index
"Given a MethodDefinition representing a Pidgin primitive definition,
this defines a PrimitiveMethod stub that will invoke the given primitive
index. Must be called after generateImageBooting:."
[
  (gen cloneOf: (gen objectNamed: #PrimitiveMethodProto)) `>>
   [setSlots: {
      #selector -> (gen generateLiteral: prim selector).
      #inputVariables -> prim roles size.
      #index -> index
    }.
    addMethodNamed: prim selector on:
      (prim roles collect:
	 [| :role |
          (role isSameAs: nodes UnaryMessage)
            ifTrue:
              [inform: ' Adding primitive %s to %s', index, role selector.
               gen objectNamed: role selector]]) ]
].

gen@(Generator traits) generateLiteral: literal
[
  literal == NoRole
    ifTrue: [gen objectNamed: #NoRoleObject]
    ifFalse: [error: 'Unsupported literal.']
].

gen@(Generator traits) generateLiteral: i@(imports SmallInteger traits)
[i].

gen@(Generator traits) generateLiteral: _@(imports BigInteger traits)
[
  error: 'The bootstrap generator does not support big integers.'
].

gen@(Generator traits) generateLiteral: _@True
[gen objectNamed: #TrueObject].

gen@(Generator traits) generateLiteral: _@False
[gen objectNamed: #FalseObject].

gen@(Generator traits) generateLiteral: _@Nil
[gen objectNamed: #NilObject].

gen@(Generator traits) generateLiteral: _@lobby
[gen objectNamed: #BootstrapObject].

gen@(Generator traits) generateLiteral: s@(imports ASCIIString traits)
[
  s isEmpty
    ifTrue: [gen objectNamed: #ASCIIStringProto]
    ifFalse: [gen cloneOf: (gen objectNamed: #ASCIIStringProto) elements:
                (s collect: #code`er into: (ByteArray newSizeOf: s))]
].

gen@(Generator traits) generateLiteral: s@(imports Symbol traits)
[
  gen symbols
    at: s
    ifAbsentPut:
      [gen cloneOf: (gen objectNamed: #SymbolProto) elements:
         (s name collect: #code`er into: (ByteArray newSizeOf: s name))]
].

gen@(Generator traits) generateLiteral: f@(imports SingleFloat traits)
[| obj |
  obj := gen cloneOf: (gen objectNamed: #FloatProto) elements: (ByteArray newWithAll: f).
  gen littleEndian = -1.0 isLittleEndian
    ifFalse: [obj elements := obj elements reversed].
  obj
].

gen@(Generator traits) generateLiteral: a@(imports ByteArray traits)
[
  a isEmpty
    ifTrue: [gen objectNamed: #ByteArrayProto]
    ifFalse: [gen cloneOf: (gen objectNamed: #ByteArrayProto) elements: a]
].

gen@(Generator traits) generateLiteral: a@(imports Array traits)
[
  a isEmpty
    ifTrue: [gen objectNamed: #ArrayProto]
    ifFalse: [gen cloneOf: (gen objectNamed: #ArrayProto) elements:
                (a collect: #(gen generateLiteral: _) `er)]
].

gen@(Generator traits) generateLiteral: c@(imports ASCIIString Character traits)
[
  gen characters at: c code
].

gen@(Generator traits) generateLiteral: block@(imports CompiledMethod traits)
[| obj |
  obj := (gen cloneOf: (gen objectNamed: #CompiledMethodProto)) `>>
   [setSlots: {
      #inputVariables -> block inputVariables.
      #localVariables -> block localVariables.
      #restVariable -> (gen generateLiteral: block restVariable).
      #heapAllocate -> (gen generateLiteral: block heapAllocate).
      #literals -> (gen generateLiteral: block literals).
      #registerCount -> (gen generateLiteral: block registerCount).
      #selectors -> (gen generateLiteral: block selectors).
      #code -> (gen generateLiteral: block code)}. ].
  obj setSlot: #method to: obj.
  block optionalKeywords isEmpty ifFalse:
    [obj setSlot: #optionalKeywords to: (gen generateLiteral: block optionalKeywords)].
  obj
].
