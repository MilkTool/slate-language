collections define: #ExtensibleSequence
	    &parents: {ExtensibleCollection. Sequence}.
"A Sequence which is Extensible. This is abstract, with several possible
implementations. A particular feature of this type is that add: maps to
addLast:, adding at the end."

es@(ExtensibleSequence traits) copyFrom: start to: end
[| result |
  end < start \/ [es isEmpty]
    ifTrue: [result := es new]
    ifFalse:
      [result := es new &capacity: end + 1 - start.
       start to: end do: [| :index | result addLast: (es at: index)]].
  result
].

es@(ExtensibleSequence traits) copyWith: obj
"Non-destructively append."
[es copy `>> [addLast: obj. ]].

es@(ExtensibleSequence traits) reversed
[| result |
  result := es newSameSize.
  es reverseDo: [| :obj |
    result addLast: obj].
  result
].

es@(ExtensibleSequence traits) growSize
"The new capacity for a call to a grow- method."
[es capacity * 2 max: 8].

es@(ExtensibleSequence traits) grow
[es growTo: es growSize].

es@(ExtensibleSequence traits) growTo: n
[overrideThis].

es@(ExtensibleSequence traits) growBy: n
[es growTo: es capacity + n].

es@(ExtensibleSequence traits) capacity
[overrideThis].

es@(ExtensibleSequence traits) addFirst: obj
"Add the given object to the beginning of the Sequence."
[overrideThis].

es@(ExtensibleSequence traits) addLast: obj
"Add the given object to the end of the Sequence."
[overrideThis].

es@(ExtensibleSequence traits) add: obj
"A particular feature of this type is that add: maps to addLast:, adding at
the end."
[es addLast: obj].

es@(ExtensibleSequence traits) append: obj
"Append the object to the Sequence; aliases addLast:."
[es addLast: obj].

es@(ExtensibleSequence traits) prepend: obj
"Prepend the object to the Sequence; aliases addFirst:."
[es addFirst: obj].

es@(ExtensibleSequence traits) addAll: c
[es addAllLast: c].

es@(ExtensibleSequence traits) addAllFirst: seq
[
  seq reverseDo: #(es addFirst: _) `er.
  seq
].

es@(ExtensibleSequence traits) addAllLast: seq
[
  seq do: #(es addLast: _) `er.
  seq
].

es@(ExtensibleSequence traits) prependAll: seq
"Prepend all of the objects to the Sequence; aliases addAllFirst:."
[es addAllFirst: seq].

es@(ExtensibleSequence traits) appendAll: seq
"Append all of the objects to the Sequence; aliases addAllLast:."
[es addAllLast: seq].

es@(ExtensibleSequence traits) collect: block
"Override to use addLast: vice at:put:."
[| result |
  result := es newSameSize.
  es do: [| :each | result addLast: (block applyWith: each)].
  result
].

es@(ExtensibleSequence traits) collect: block from: start to: end
"Override to use addLast: vice at:put:."
[| result |
  start < 0 \/ [end >= es size]
    ifTrue: [result := es new]
    ifFalse:
      [result := es new &capacity: end - start + 1.
       start to: end do:
         [| :index | result addLast: (block applyWith: (es at: index))]].
  result
].

es@(ExtensibleSequence traits) with: seq collect: binBlock
[| result |
  result := es new &capacity: (es size min: seq size).
  0 below: result capacity do: [| :index |
    result addLast: (binBlock applyWith: (es at: index) with: (seq at: index))].
  result
].

es@(ExtensibleSequence traits) removeFirst
"Removes and answers the first element."
[overrideThis].

es@(ExtensibleSequence traits) removeLast
"Removes and answers the last element."
[overrideThis].

es@(ExtensibleSequence traits) remove
"Removes from the front by default, providing LIFO semantics in combination
with add:->addLast:."
[es removeFirst].

es@(ExtensibleSequence traits) removeFirst: n
[| result |
  n > es size ifTrue: [n := es size].
  result := es new &capacity: n.
  n timesRepeat: [result addLast: n removeFirst].
  result
].

es@(ExtensibleSequence traits) removeLast: n
[| result |
  n > es size ifTrue: [n := es size].
  result := es new &capacity: n.
  n timesRepeat: [result addFirst: es removeLast].
  result
].

collections define: #ArrayBacked &parents: {ExtensibleSequence} &slots: {#contents -> {}}.
"This merely provides an area for common methods for various implementation
extensions of ExtensibleSequence which use a contents Array to store their
elements."

es@(ArrayBacked traits) clear
[es contents clear. ].

es@(ArrayBacked traits) copy
[es cloneSettingSlots: #{#contents} to: {es contents copy}].

es@(ArrayBacked traits) new &capacity: n
[es cloneSettingSlots: #{#contents}
    to: {es contents new &capacity: (n ifNil: [es contents size max: 4])}].

es@(ArrayBacked traits) arrayType
"The underlying implementation prototype."
[es contents arrayType].

es@(ArrayBacked traits) elementType
"The underlying implementation element type accepted."
[es contents elementType].

es@(ArrayBacked traits) capacity
[es contents size].

es@(ArrayBacked traits) growTo: n
[| result |
  result := es contents new &capacity: n.
  result replaceFrom: 0 to: es size - 1 with: es contents.
  es contents := result.
  es
].

s@(Sequence traits) as: es@(ArrayBacked traits)
"Allows dynamically carrying forward the arrayType into the new Sequence."
[
  es new `>> [contents := s arrayType newSizeOf: s.
	      addAll: s. ]
].

es@(ArrayBacked traits) convertContentsTo: s
[
  es contents := es contents as: s. es
].

collections define: #ExtensibleArray &parents: {ArrayBacked} &slots: {#firstIndex -> 0. #lastIndex -> -1}.
"An ExtensibleArray implemented by an Array with padding on both ends for
the contents."

es@(ExtensibleArray traits) new &capacity: n
[resend `>> [firstIndex := 0. lastIndex := -1. ]].

es@(ExtensibleArray traits) size
[
  es lastIndex - es firstIndex + 1
].

es@(ExtensibleArray traits) at: index
[
  (es includesKey: index)
    ifTrue: [es contents at: es firstIndex + index]
    ifFalse: [index keyNotFoundOn: es]
].

es@(ExtensibleArray traits) at: index put: value
[
  (es includesKey: index)
    ifTrue: [es contents at: es firstIndex + index put: value]
    ifFalse: [index keyNotFoundOn: es]
].

es@(ExtensibleArray traits) clear
"Resets to the values for being empty. lastIndex is -1 to coordinate with the
size method and addLast:."
[
  resend.
  es firstIndex := 0.
  es lastIndex := -1.
  es
].

es@(ExtensibleArray traits) copyReplaceFrom: start to: end with: c
"Performs an insert or append as necessary if the replacing collection doesn't
fit in the bounds. eg start < 0 prepends, start > size appends."
[| result delta startIndex endIndex ess cs |
  delta := 0.
  ess := es size.
  cs := c size.
  start < 0
    ifTrue: [startIndex := endIndex := 0]
    ifFalse:
      [endIndex := end.
       (startIndex := start) > ess
         ifTrue: [startIndex := endIndex := size + 1]
         ifFalse: [endIndex < (startIndex - 1) \/ [endIndex > (ess - 1)]
                     ifTrue: [^ Nil].
                   delta := endIndex - startIndex + 1]].
  result := es new &capacity: ess + cs - delta.
  0 below: startIndex do: [| :index | result add: (es at: index)].
  0 below: cs do: [| :index | result add: (c at: index)].
  endIndex + 1 below: ess do: [| :index | result add: (es at: index)].
  result
].

es@(ExtensibleArray traits) growFirst &by: growBy
"Provide a larger array and map the contents in to yield more growth area at
the beginning. The growth factor is 2."
[| newContents offset defaultGrowBy |
  defaultGrowBy := es growSize - es capacity.
  growBy := (growBy
    ifNil: [defaultGrowBy]
    ifNotNil: [growBy max: defaultGrowBy]).
  newContents := (es lastIndex + growBy >= (es capacity - 1)
    ifTrue: [es contents new &capacity: es capacity + growBy]
    ifFalse: [es contents]).
  offset := newContents size - es lastIndex - 1.
  es lastIndex downTo: es firstIndex do:
    [| :index | newContents at: index + offset put: (es contents at: index)].
  es firstIndex := es firstIndex + offset.
  es lastIndex := es lastIndex + offset.
  es contents := newContents
].

es@(ExtensibleArray traits) grow
"This is the default for growing since add: addLast:s."
[es growLast].

es@(ExtensibleArray traits) growLast &by: growBy
"Provide a larger array and map the contents in to yield more growth area at
the end. The growth factor is 2."
[| newContents defaultGrowBy |
  defaultGrowBy := es growSize - es capacity.
  growBy := (growBy
    ifNil: [defaultGrowBy]
    ifNotNil: [growBy max: defaultGrowBy]).
  newContents := (es firstIndex - growBy <= 0
    ifTrue: [es contents new &capacity: es capacity + growBy]
    ifFalse: [es contents]).
  es firstIndex upTo: es lastIndex do:
    [| :index |
     newContents
       at: index - es firstIndex
       put: (es contents at: index)].
  es lastIndex := es lastIndex - es firstIndex.
  es firstIndex := 0.
  es contents := newContents
].

es@(ExtensibleArray traits) addFirst: obj
[| firstIndex |
  (firstIndex := es firstIndex) = 0 ifTrue: [es growFirst].
  es firstIndex := es firstIndex - 1.
  es contents at: es firstIndex put: obj.
  obj
].

es@(ExtensibleArray traits) addLast: obj
[
  es lastIndex + 1 < es capacity ifFalse: [es growLast].
  es lastIndex := es lastIndex + 1.
  es contents at: es lastIndex put: obj.
  obj
].

es@(ExtensibleArray traits) insert: obj after: member
[
  es add: obj after: member
].

es@(ExtensibleArray traits) add: obj after: member
[
  (es find: member) ifNotNilDo:
    [| :index | es at: index + 1 insert: obj. obj]
].

es@(ExtensibleArray traits) insert: obj before: member
[
  es add: obj before: member
].

es@(ExtensibleArray traits) add: obj before: member
[
  (es find: member) ifNotNilDo:
    [| :index | es at: index insert: obj. obj]
].

es@(ExtensibleArray traits) remove: obj ifAbsent: block
[| index |
  index := es firstIndex.
  [index <= es lastIndex] whileTrue:
    [obj = (es contents at: index)
      ifTrue: [es contents replaceFrom: index to: es lastIndex - 1
          with: es contents startingAt: index + 1.
          es contents at: es lastIndex put: es contents defaultElement.
          es lastIndex := es lastIndex - 1.
          ^ obj]
      ifFalse: [index := index + 1]].
  block do
].

es@(ExtensibleArray traits) removeAllSuchThat: test
"Remove each element of the receiver for which aBlock evaluates to true.
The method in ExtensibleCollection is O(N^2); this is O(N)."
[| n |
  n := es firstIndex.
  es firstIndex to: es lastIndex do:
   [| :index |
    (test applyWith: (es contents at: index)) ifFalse:
      [es contents at: n put: (es contents at: index).
       n := n + 1]].
  n to: es lastIndex do: [| :index | es contents at: index put: Nil].
  es lastIndex := n - 1.
  es
].

es@(ExtensibleArray traits) at: index remove: n
"Remove the next N objects currently starting from the given index, sliding
items from the right over to fill in the places."
[| localStart |
  localStart := index + es firstIndex.
  es contents replaceFrom: localStart to: es lastIndex - n
      with: es contents startingAt: localStart + n.
  es lastIndex := es lastIndex - n.
  es
].

es@(ExtensibleArray traits) removeAt: index
"Remove the object currently at the given index, sliding items from the right
over to fill in the place."
[| removed localIndex |
  removed := es at: index.
  localIndex := index + es firstIndex.
  es contents replaceFrom: localIndex to: es lastIndex - 1
      with: es contents startingAt: localIndex + 1.
  es contents at: es lastIndex put: es contents defaultElement.
  es lastIndex := es lastIndex - 1.
  removed
].

es@(ExtensibleArray traits) removeFirst
[| firstObj |
  es emptyCheck.
  firstObj := es contents at: es firstIndex.
  es contents at: es firstIndex put: es contents defaultElement.
  es firstIndex := es firstIndex + 1.
  firstObj
].

es@(ExtensibleArray traits) removeLast
[| lastObj |
  es emptyCheck.
  lastObj := es contents at: es lastIndex.
  es contents at: es lastIndex put: es contents defaultElement.
  es lastIndex := es lastIndex - 1.
  lastObj
].

es@(ExtensibleArray traits) removeFirst: n
[| result i |
  n > es size ifTrue: [n := es size].
  result := es contents new &capacity: n.
  es firstIndex below: es firstIndex + n do:
    [| :i | result at: i put: (es contents at: i).
     es contents at: i put: es contents defaultElement].
  es firstIndex := es firstIndex + n.
  result
].

es@(ExtensibleArray traits) removeLast: n
[| result |
  n > es size ifTrue: [n := es size].
  result := es contents new &capacity: n.
  es lastIndex above: (es lastIndex := es lastIndex - n)
    do: [| :i | result at: (n := n - 1) put: (es contents at: i).
	 es contents at: i put: es contents defaultElement].
  result
].

c@(Collection traits) collect: block into: es@(ExtensibleArray traits)
"Override to use the specific implementation."
[
  c do: [| :each | es addLast: (block applyWith: each)].
  es
].

es@(ExtensibleArray traits) collect: block from: start to: end
"Override to use the specific implementation."
[| result |
  start < 0 \/ [end >= es size]
    ifTrue: [result := es new]
    ifFalse:
      [result := es new &capacity: end - start + 1.
       es firstIndex + start to: es firstIndex + end do:
         [| :index | result addLast: (block applyWith: (es contents at: index))]].
  result
].

es@(ExtensibleArray traits) do: block
[| index limit |
  index := es firstIndex.
  limit := es lastIndex.
  [index <= limit] whileTrue:
    [block applyWith: (es contents at: index).
     index := index + 1].
  es
].

es@(ExtensibleArray traits) reverseDo: block
[| index |
  index := es lastIndex.
  [index >= es firstIndex] whileTrue:
    [block applyWith: (es contents at: index).
     index := index - 1].
  es
].

c@(Collection traits) select: block into: es@(ExtensibleArray traits)
[
  c do: [| :each | (block applyWith: each) ifTrue: [es addLast: each]].
  es
].

c@(Sequence traits) collectWithIndex: binBlock into: es@(ExtensibleArray traits)
"Override to use addLast: vice at:put:."
[
  c doWithIndex:
    [| :each :index | es addLast: (block applyWith: each with: index)].
  es
].

es@(ExtensibleArray traits) find: obj
[| index |
  index := es firstIndex.
  [index <= es lastIndex] whileTrue:
    [(es contents at: index) = obj ifTrue: [^ index].
     index := index + 1].
  Nil
].

es@(ExtensibleArray traits) makeGapAt: index &size: size
"Make a gap at the requested index, and return the start offset of
the created gap in the contents array."
[
  size `defaultsTo: 1.
  `conditions: (
    [size isNegative]
      -> [error: 'Gap size must be bigger then 0'].
    [index isNegative \/ [index > es size]]
      -> [index keyNotFoundOn: es].
    [index isZero]
      -> [es firstIndex - size < 0 ifTrue: [es growFirst &by: size].
          es firstIndex := es firstIndex - size]
  ) otherwise:
    [| contentsIndex |
     es lastIndex + size >= es capacity ifTrue: [es growLast &by: size].
     contentsIndex := es firstIndex + index.
     index = es size ifFalse:
       [es contents
          replaceFrom: contentsIndex + size
          to: es lastIndex + size
          with: es contents
          startingAt: contentsIndex].
     es lastIndex := es lastIndex + size.
     contentsIndex]
].

es@(ExtensibleArray traits) at: index insert: obj
[| contentsIndex |
  es contents at: (contentsIndex := es makeGapAt: index) put: obj
].

es@(ExtensibleArray traits) at: index insertAll: col
[| startOffset |
  startOffset := es makeGapAt: index &size: col size.
  col doWithIndex: [| :each :index | es contents at: startOffset + index put: each].
  es
].

es@(ExtensibleArray traits) move: obj to: index
"Re-position the object so that it has the given index, and slide up/down other
objects as needed."
[| src tgt |
  (src := es find: obj)
    ifNil: [obj elementNotFoundOn: es].
  (tgt := index + es startIndex) = src ifFalse:
    [src > tgt
       ifTrue:
         [es contents
            replaceFrom: tgt + 1
            to: src
            with: es contents
            startingAt: tgt]
       ifFalse:
         [es contents
            replaceFrom: src
            to: es contents lastIndex
            with: es contents
            startingAt: src + 1].
     es contents at: tgt put: obj].
  es
].

"this will call the correct #as function when converting to strings"
collections define: #ExtensibleByteArray &parents: {ExtensibleArray}.
ExtensibleByteArray contents := ByteArray new.

es@(ExtensibleByteArray traits) elementType [SmallInteger].

es@(ExtensibleByteArray traits) as: s@(String traits)
[| result |
  result := s newSizeOf: es.
  es doWithIndex:
    [| :each :index | result at: index put: (each as: s elementType)].
  result
].

s@(ASCIIString traits) as: a@(ExtensibleByteArray traits)
[| result |
  result := a new &capacity: s size.
  s do: [| :each | result add: (each as: a elementType)].
  result
].
