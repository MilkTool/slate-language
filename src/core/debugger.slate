
"DebugConsole writeStream collectionLimit: 512.
DebugConsole writeStream nestingLimit: 3.
Stream PrettyPrinter collectionLimit: 512.
Stream PrettyPrinter nestingLimit: 3."

Stream PrettyPrinter collectionLimit: 256.
Stream PrettyPrinter nestingLimit: 2.

conditions define: #Debugger &parents: {Cloneable}
  &slots: {#condition -> Nil.
           #restarts -> ExtensibleArray new.
           #interpreter -> bootstrapInterpreter.
           #resource -> DebugConsole.
           #parser -> Syntax Parser.
           #printer -> DebugConsole writer.
           #namespace -> lobby newSubSpace.
           #frameList -> ExtensibleArray new.
           #currentFrame -> Nil.
           #baseFramePointer -> Nil.
           #slateFrameSize -> 6.
           #maxBacktraceSize -> 200.
           #basePrompt -> '> '}.

d@(Debugger traits) refreshWorkspace
[d namespace: d namespace newSisterSpace. d installMethods].

d@(Debugger traits) on: resource
[
  d resource: resource.
  d parser: (d parser newOn: resource reader).
  d printer: resource writer.
  d printer collectionLimit: Stream PrettyPrinter collectionLimit.
  d printer nestingLimit: Stream PrettyPrinter nestingLimit.
  d
].

d@(Debugger traits) newFor: c &interpreter: interp &console: resource &topMethod: symbol
[
  interp `defaultsTo: d interpreter.
  resource `defaultsTo: d resource.
  symbol `defaultsTo: #invokeDebugger.
  d clone `>>
    [| :newD |
     on: resource.
     condition: c.
     restarts: d restarts new.
     namespace: d namespace clone.
     parser currentScope: (Syntax Namespace for: newD namespace).
     parser parseInteractively:
       ([repl parser parseInteractively]
	  on: SeriousCondition do: [| :c | c return: False]).
     baseFramePointer: (d interpreter framePointerOf: symbol).
     buildFrames. ]
].

c@(Condition traits) invokeDebugger
"The hook for any Condition to start the debugger and enter its loop."
[(Debugger newFor: c) enter].

d@(Debugger traits) findRestarts
"Rebuilds the list of applicable restarts."
[
  d restarts clear.
  conditionStack
    reverseDo:
      [| :context |
       (context is: Restart) /\ [context appliesTo: d condition]
	 ifTrue: [d restarts addLast: context]].
  d restarts
].

d@(Debugger traits) describeRestartAt: index
[| out restart |
  out: d printer.
  restart: (d restarts at: index).
  out ; 'restart: ' ; index printString ; '\t'.
  restart describeOn: out.
].

d@(Debugger traits) describeRestarts
"Describes the restarts available in the context, if any."
[| out |
  out: d printer.
  out ; 'The following condition was signaled:\n'.
  d condition describeOn: out.
  out ; '\n'.
  out ; (d restarts isEmpty
    ifTrue: ['No restarts are available.\n']
    ifFalse: ['Available Restarts:\n']).
  d restarts isEmpty
    ifTrue: [out ; '(none available)']
    ifFalse: [d restarts keysDo: [| :index | d describeRestartAt: index]].
].

d@(Debugger traits) stackAt: x
[
  d interpreter stack at: x
].

d@(Debugger traits) stackAt: x put: val
[
  d interpreter stack at: x put: val
].

Debugger traits define: #Frame &parents: {Cloneable}
  &slots: #(debugger framePointer).

f@(Debugger Frame traits) newOn: d@(Debugger traits) at: fp
[
  fp > d slateFrameSize
    ifTrue: [f cloneSettingSlots: #(debugger framePointer) to: {d. fp}]
].

f@(Debugger Frame traits) newAtTopOf: d@(Debugger traits)
[
  f cloneSettingSlots: #(debugger framePointer) to: {d. d baseFramePointer}
].

f@(Debugger Frame traits) nextFrame
[
  f newOn: f debugger at: f callerFrameIndex
].

f@(Debugger Frame traits) stackAtOffset: offset
[f debugger stackAt: f framePointer + offset].

f@(Debugger Frame traits) stackAtOffset: offset put: value
[f debugger stackAt: f framePointer + offset put: value].

f@(Debugger Frame traits) callerFrameIndex
[f stackAtOffset: -1].

f@(Debugger Frame traits) lexicalContext
[f stackAtOffset: -2].

f@(Debugger Frame traits) method
[f stackAtOffset: -3].

f@(Debugger Frame traits) instructionPointer
[f stackAtOffset: -4].

f@(Debugger Frame traits) resultStackLocation
[f stackAtOffset: -5].

f@(Debugger Frame traits) previousStackPointer
[f stackAtOffset: -6].

f@(Debugger Frame traits) callerFrameIndex: fp
[f stackAtOffset: -1 put: fp].

f@(Debugger Frame traits) lexicalContext: lc
[f stackAtOffset: -2 put: lc].

f@(Debugger Frame traits) method: m
[f stackAtOffset: -3 put: m].

f@(Debugger Frame traits) instructionPointer: ip
[f stackAtOffset: -4 put: ip].

f@(Debugger Frame traits) resultStackLocation: rp
[f stackAtOffset: -5 put: rp].

f@(Debugger Frame traits) previousStackPointer: sp
[f stackAtOffset: -6 put: sp].

f@(Debugger Frame traits) describeOn: out
[
  method: f method method.
  out
    ; 'frame: ' ; (f debugger frameList indexOf: frame) printString ; '\n'
    ; '  FP: ' ; frame framePointer printString  ; '\n'
    ; '  IP: ' ; frame instructionPointer printString ; '\n'
    ; 'method: ' ; method printString ; ' @ ' ; method definitionLocation ; '\n'
    ; '  call count: ' ; method callCount printString ; '\n'
    ; '  register count: ' ; method registerCount printString ; '\n'
    ; '  code size: ' ; method code size printString ; '\n'
    ; '  source: ' ; method sourceTree printString ; '\n'.
  out ; 'Inputs:\n'.
  0 below: method inputVariables
    do: [|:i| out ; ' arg: ' ; i printString ; '\t' ; (frame stackAtOffset: i) printString ; '\n'].
  out ; 'Locals:\n'.
  method inputVariables below: method inputVariables + method localVariables
    do: [|:i| out ; ' arg: ' ; i printString ; '\t' ; (frame stackAtOffset: i) printString ; '\n'].
  out ; 'Registers:\n'.
  method inputVariables + method localVariables below: method registerCount
    do: [|:i| out ; ' arg: ' ; i printString ; '\t' ; (frame stackAtOffset: i) printString ; '\n'].
  out ; 'Decompiled: ' ; '\n'.
  VM SSACompiler decompile: method code.
].

d@(Debugger traits) topFrame
[d Frame newAtTopOf: d].

d@(Debugger traits) buildFrames
[| frame |
  d baseFramePointer ifNil: [error: 'Base frame pointer is nil. Cannot build stack frames.\n'. ^ Nil].
  d frameList: d frameList new.
  d frameList add: (frame: d topFrame).
  [(frame: frame nextFrame) isNotNil] whileTrue: [d frameList add: frame].
].

d@(Debugger traits) prompt
[
  [| :out |
   out ; 'slate-debug'.
   d restarts isEmpty
     ifFalse: [out ; '[0'.
	       d restarts size > 1 ifTrue:
		 [out ; '..' ; d restarts indexLast printString].
	       out ; ']'].
   out ; d basePrompt] writingAs: ''
].

d@(Debugger traits) signalRestartAt: index
"Takes the restart option number from the queryRestart and invokes it."
[
  (d restarts acceptsKey: index)
    ifTrue: [((d restarts at: index) newCondition: d condition)
	       `>> [queryFrom: d. signal]]
    ifFalse: [d resource ; index printString ; ' is not a valid restart.\n']
].

d@(Debugger traits) printFrameLineAt: index &stream: out &showLocation: showLocation
[| frame |
  out `defaultsTo: d printer.
  showLocation `defaultsTo: False.
  frame: (d frameList at: index).
  out ; 'frame: ' ; index printString ; (d currentFrame = frame ifTrue: [' *'] ifFalse: ['']) ; '\t' ; frame method printString.
  showLocation ifTrue: [out ; ' @ ' ; frame method method definitionLocation].
  out ; '\n'.
].

d@(Debugger traits) printBacktrace &limit: limit &stream: out &showLocation: showLocation
[ 
  limit `defaultsTo: d maxBacktraceSize.
  out `defaultsTo: d printer.
  showLocation `defaultsTo: False.
  out ; 'Backtrace (method @ source): \n'.
  0 below: (d frameList length min: limit) do:
    [| :index | d printFrameLineAt: index &showLocation: showLocation].
].

d@(Debugger traits) frame: index
"Selects the frame at the given index."
[
  d currentFrame: (d frameList at: index ifAbsent: [Nil]).
  d printFrame
].

d@(Debugger traits) top
[
  d currentFrame: d frameList first
].

d@(Debugger traits) up
[
  (d frameList before: d currentFrame)
    ifNil: [error: 'You are at the top of the stack and cannot go up a frame']
    ifNotNilDo: [| :frame | d currentFrame: frame]
].

d@(Debugger traits) down
[
  (d frameList after: d currentFrame)
    ifNil: [error: 'You are at the bottom of the stack and cannot go down a frame']
    ifNotNilDo: [| :frame | d currentFrame: frame]
].

d@(Debugger traits) currentFrameValueAt: n
[| out frame method |
  out: d printer.
  frame: d currentFrame.
  frame ifNil: [^ (out ; 'No frame currently selected. Use "frame: N"')].
  method: frame method method.
  d currentFrame ifNil: [inform: 'Current frame is nil'. ^ Nil].
  out ; 'register[' ; n printString ; ']@' ; (frame stackAtOffset: n) printName
    ; '\t' ; (frame stackAtOffset: n) printString ; '\n'.
  frame stackAtOffset: n
].

d@(Debugger traits) currentFrameValueAt: n put: val
[
  d currentFrame stackAtOffset: n put: val
].

d@(Debugger traits) printFrame
[| out |
  out: d printer.
  d currentFrame
    ifNil: [^ (d printer ; 'No frame currently selected. Use "frame: N"')]
    ifNotNilDo: [| :frame | frame describeOn: d printer]
].

d@(Debugger traits) printHelp
[
  d printer
   ; 'The debugger is a specialized evaluator that evaluates expressions within the method currently being debugged. Certain messages are provided for changing the state of the debugger, as follows:\n'
   ; ': index. (or restart: index.)\n\tSignal the restart at the given index\n'
   ; 'backtrace (or "bt")\n\tPrint the backtrace\n'
   ; 'frame\n\tPrint the current frame\n'
   ; 'frame: N\n\tSet the current frame\n'
   ; 'down\n\tMove down one frame (to the caller)\n'
   ; 'up\n\tMove up one frame (in the callee direction)\n'
   ; 'arg: N\n\tDisplays the frame\'s register at index N\n'
   ; 'arg: N put:\n\tSets the frame\'s register at index N\n'
   ; 'restarts\n\tPrint the currently available restarts\n'
   ; 'help\n\tPrint this help listing\n'.
].

d@(Debugger traits) installMethods
[
  _@(d namespace) debugger
  [d].
  _@(d namespace) frame
  [d printFrame].
  _@(d namespace) True
  [True].
  _@(d namespace) False
  [False].
  _@(d namespace) frame
  [d currentFrame].
  _@(d namespace) frame: n
  [d frame: n].
  _@(d namespace) top
  [d top].
  _@(d namespace) up
  [d up].
  _@(d namespace) down
  [d down].
  _@(d namespace) arg: n
  [d currentFrameValueAt: n].
  _@(d namespace) arg: n put: newVal
  [d currentFrameValueAt: n put: newVal].
  _@(d namespace) backtrace &limit: n &showLocation: showLocation
  [d printBacktrace &limit: n &showLocation: (showLocation ifNil: [True])].
  _@(d namespace) bt &limit: n &showLocation: showLocation
  [d printBacktrace &limit: n &showLocation: (showLocation ifNil: [True])].
  _@(d namespace) restarts
  [d describeRestarts].
  _@(d namespace) restart: index
  [d signalRestartAt: index].
  _@(d namespace) : index
  [d signalRestartAt: index].
  _@(d namespace) help
  [d printHelp].
].

d@(Debugger traits) enter
"The main interactive debugger loop."
[| out |
  out: d printer.
  out ; 'Debugging: ' ; d condition printName ; '\n'.
  d refreshWorkspace.
  d findRestarts.
  d printBacktrace &showLocation: True.
  d describeRestarts.
  out ; '\nEnter \'help.\' for instructions.\n'.

  [
  "Print out the restarting options with a prompt and numeric labels, and read
in the selected option number, returning it if valid."
  out ; d prompt.
  out flush.
  [| expr result restartNumeric |
   expr: d parser next.
   result: (expr evaluateIn: d namespace).
   restartNumeric: (expr is: Syntax Literal) /\ [result is: Integer].
   "Exclude selections of restarts and other commands from printing."
   restartNumeric \/
     [(expr is: Syntax Message) /\ [#(: restart: frame frame: restarts help bt backtrace) includes: expr selector]]
      ifFalse:
        [result printOn: out.
          out newLine.
          out flush].
   restartNumeric ifTrue: [d signalRestartAt: result].
   ] on: SeriousCondition
    do: [| :c |
      out ; '\nThe following condition was signaled from within the debugger:\n'.
      c describeOn: d printer.
      (c is: Stream Exhaustion) /\ [c stream resource handle = 0] ifTrue: [out ; 'End of input, exiting...\n'. lobby exit: 1].
      c exit]] loop.
].
