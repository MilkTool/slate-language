
streams define: #LimitedProcessor &parents: {StreamProcessor} &slots: {#count -> 0}.

s@(LimitedProcessor traits) for: n
[
  s clone `>> [count: n. ]
].


s@(LimitedProcessor traits) isAtEnd
[
  s count <= s count zero \/ [resend]
].


s@(LimitedProcessor traits) next
[
  s count: s count - 1.
  s source next
].

streams define: #PeekableProcessor &parents: {StreamProcessor} &slots: {#readBuffer}.

pps@(PeekableProcessor traits) on: s
[
  resend `>> [readBuffer: s collectionType new. ]
].


s@(PeekableProcessor traits) next
[
  (s next: 1) first
].

s@(PeekableProcessor traits) next: n
[ | next readBufSize |
  s readBuffer isEmpty ifTrue: [^ (s source next: n)].
  readBufSize: s readBuffer size.
  n <= readBufSize
    ifTrue: [next: (s readBuffer first: n).
             s readBuffer: (s readBuffer allButFirst: n)]
    ifFalse: [next: (s readBuffer first: readBufSize) ; (s source next: n - readBufSize).
              s readBuffer: s readBuffer new].
  next isEmpty ifTrue: [^ s exhausted].
  next
].

s@(PeekableProcessor traits) skip: n
[ | readBufSize |
  s readBuffer isEmpty ifTrue: [^ (s source skip: n)].
  readBufSize: s readBuffer size.
  n <= readBufSize
    ifTrue: [s readBuffer: (s readBuffer allButFirst: n)]
    ifFalse: [s source skip: n - readBufSize.
              s readBuffer: s readBuffer new].
  
].


s@(PeekableProcessor traits) peek
[
  (s peek: 1) first
].

s@(PeekableProcessor traits) peek: n
[
  s readBuffer size < n ifTrue: [s readBuffer: s readBuffer ; (s source next: n - s readBuffer size)].
  s readBuffer size < n ifTrue: [s exhausted] ifFalse: [s readBuffer first: n]
].

s@(PeekableProcessor traits) isAtEnd
[
  s source isAtEnd /\ [s readBuffer isEmpty]
].


streams define: #OutputBufferedProcessor &parents: {StreamProcessor} &slots: {#outputBuffer}.


ps@(OutputBufferedProcessor traits) on: s
[
  resend `>> [outputBuffer: s collectionType new. ]
].


s@(OutputBufferedProcessor traits) next
[
  (s next: 1) first
].

s@(OutputBufferedProcessor traits) next: n
[
  s outputBuffer isEmpty ifTrue: [^ (s source next: n)].
  s outputBuffer size < n ifTrue: [^ (s grabFirst: s outputBuffer size) ; (s source next: n - s outputBuffer size)].
  s grabFirst: n
].

s@(OutputBufferedProcessor traits) inject: seq
[
  s outputBuffer: s outputBuffer ; seq.
].

s@(OutputBufferedProcessor traits) grabFirst: n
[ | next |
  s outputBuffer size < n ifTrue: [^ s exhausted].
  next: (s outputBuffer first: n).
  s outputBuffer: (s outputBuffer allButFirst: n).
  next
].

s@(OutputBufferedProcessor traits) isAtEnd
[
  s outputBuffer isEmpty /\ [resend]
].


streams define: #SimpleReplacementStream &parents: {OutputBufferedProcessor. PeekableProcessor} &slots: {#search. #replace}.

s@(SimpleReplacementStream traits) find: x replaceWith: y
[
  s new `>> [search: x. replace: y. ]
].


s@(SimpleReplacementStream traits) next: n
[ | next |  
  s search isEmpty ifTrue: [^ (s source next: n)].
  
  [s outputBuffer size < n /\ [s isAtEnd not]] whileTrue:
    [([(s peek: s search size) = s search] on: Stream Exhaustion do: [|:c| c return: False])
       ifTrue: [s skip: s search size. s inject: s replace]
       ifFalse: [next: (s peek: 1).
                 s skip: 1. "skip before inject otherwise we aren't doing anything"
                 s inject: next]].
  s grabFirst: n
].


s@(Sequence traits) find: find@(Sequence traits) replaceWith: replace@(Sequence traits)
[ | out |
  out: s new writer.
  s reader >> (SimpleReplacementStream find: find replaceWith: replace) >> out.
  out contents
].

