Gtk define: #Main &builder: [Oddball clone] &slots: { #initialized -> False. #oldDebuggerHook }.

_@(Gtk Main) printName [ 'Gtk Main' ].

_@(Gtk Main) mainQuit [
	Gtk Lib primitives gtk_main_quit do
].

m@(Gtk Main) installDebuggerHook [
  m oldDebuggerHook: (#invokeDebugger findOn: {Condition traits}).
  c@(Condition traits) invokeDebugger [ 
	"The hook for any Condition to start the debugger and enter its loop."
	| stream dialog message |
	stream: (Stream newTo: String new).
	c describeOn: stream.
	message: (stream contents ; 'Debug it?' ).
	dialog: (Gtk MessageDialog newQuestionMessage: message).
	dialog when: #response do: [ | :dialog :answer | 
		dialog destroy.
		answer = Gtk ResponseType Yes ifTrue: [ (Gtk Debugger newFor: c) show ]
	].
	dialog show.
	Gtk Main doEventLoop.
  ].
].

m@(Gtk Main) uninstallDebuggerHook [
	| myDebuggerHook |
	myDebuggerHook: (#invokeDebugger findOn: {Condition traits}).
	myDebuggerHook ifNil: [ ^ Nil ].
	m oldDebuggerHook
		ifNil: [ myDebuggerHook removeFrom: {Condition traits} ]
		ifNotNil: [ myDebuggerHook replaceWith: m oldDebuggerHook on: {Condition traits} ]
].

m@(Gtk Main) init [
	m initialized ifFalse: [
		Gdk LibWrapper init.
		GLib CallbackData initQueue.
		GLib CallbackRegistry init.
		Gtk LibWrapper init.
		m initialized: True.
		m installDebuggerHook.
	]
].

m@(Gtk Main) uninitialize [
	m uninstallDebuggerHook.
	m oldDebuggerHook: Nil.
	GLib CallbackRegistry uninitialize.
	m initialized: False.
].

m@(Gtk Main) shutdown [
	m initialized ifTrue: [
		m mainQuit.
		GLib CallbackData shutdownQueue.
		m uninitialize.
	]
].

m@(Gtk Main) resetOnStartup [
"Adds a handler for Image startup to reset the REPL."
	Image startupActions at: m put: [ m uninitialize ].
].

m@(Gtk Main) doEventLoop [
	[	GLib CallbackRegistry executeNextCallback.
	"initialized will be cleared on startup, and we should not use any pre shutdown object in new images"
		m initialized
 	] whileTrue
].

m@(Gtk Main) do: aBlock [
	m init.
	aBlock do.
	m doEventLoop.
	m shutdown.
].
